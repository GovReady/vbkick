#!/bin/bash

# The MIT License
#
# Copyright (c) 2013, Kamil Wilas (wilas.pl)
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

# Help build Virtualbox guest VMs and Vagrant base boxes

# Secure bash
# More about options: http://wiki.bash-hackers.org/commands/builtin/set
# treat unset variables as an error
# (it also complain if you forget about required options in definition.cfg)
set -u;
# exit when cmd fail (use ERR trap for clean exit)
set -e; set -E;
# fail the entire pipeline if any part of it fails
set -o pipefail;
# debug mode
#set -x;
# http://mywiki.wooledge.org/glob
shopt -s failglob;
# enable POSIX mode
# http://www.gnu.org/software/bash/manual/html_node/Bash-POSIX-Mode.html
set -o posix    

# VM default settings - basic
hostiocache="on"
cpu_count=1
memory_size=512
disk_size=10140
disk_format="vdi"
video_memory_size=10
# list of VM options: ("option1:value" "option2:value")
vm_options=("ioapic:on")
# by default gui enabled
gui_enabled=1
# by default add shared folder - to disable: shared_folder=""
shared_folder="vbkick"

# ISO default settings
# default path to directory with iso files
iso_path="iso"
# by default sha256sum is empty - 
# WARNING is given during processing if sha256 sum is wrong (use: sha256sum --help)
iso_sha256=""
# set to 1 to download custom VBoxGuestAdditions on host, otherwise use default VBoxGuestAdditions - recommended
guest_additions_download=0

# Boot default settings
# default time before boot_cmd_sequence start
boot_wait=10
# list of boot_cmd: ("cmd1" "cmd2" "cmd3")
boot_cmd_sequence=("")
# default number of second wait between each boot_cmd
boot_seq_wait=1
# default webserver port to serve kickstart files
kickstart_port=7122
# default max webserver live time
kickstart_timeout=7200

# SSH default settings (veeded to run vbkick validate and/or lazy_posinstall)
# by default use ssh keys
ssh_keys_enabled=1
# default user
ssh_user="vbkick"
# default path to ssh keys
ssh_keys_path="keys"
# default private key name
ssh_priv_key="vbkick_key"
# default auto-download path 
ssh_priv_key_src="https://raw.github.com/wilas/vbkick/master/keys/vbkick_key"
# default ssh host port
ssh_host_port=2222
# default (22) ssh guest port to forwarding
ssh_guest_port=22
# default extra ssh and scp options
# UserKnownHostsFile - database file to use for storing the user host keys
# StrictHostKeyChecking - if "no" then automatically add new host keys to the host key database file
# you may consider editing ssh config: http://superuser.com/questions/141344/ssh-dont-add-hostkey-to-known-hosts
ssh_options="-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"

# Lazy Postinstall default settings
# list of files and directories to transport to guest
postinstall_transport=("")
# list of postinstall commands
postinstall_launch=("")

# Validate default settings
# list of files and directories to transport to guest
validate_transport=("")
# list of validate commands
validate_launch=("")

# Lazy Update default settings
# list of files and directories to transport to guest
update_transport=("")
# list of update commands
update_launch=("")
# default command to update VBoxGuestAdditions
manuall_update_guest_additions="sudo mount /dev/sr1 /mnt && sudo sh /mnt/VBoxLinuxAdditions.run && sudo umount /mnt"

# Clean
# list of files to autoupdate VBOX_VERSION value
files_to_autoupdate_vbox_version=("")
# rm or not already transported via SCP files/directories (from postinstall, validate)
clean_transported=0
# nice for OS shutdown command
shutdown_cmd="sudo /sbin/halt -h -p"
# when timeout is reached and VM is still running, hard poweroff is used
shutdown_timeout=20

# Other global variables - do not use it in definition.cfg (will be overwrite during program runtime)
# virtual machine name
VM=""
# 0 - webserver is not running or kill isn't able to stop it
webserver_status=0
# 0 - webserver was killed cleanly or we didn't try kill it yet
webserver_kill_status=0
# during exporting tmp directory is created
tmp_dir=""
# during exporting NAT mapping is removed (temporary) - help recover state before exporting
natmapping_was_removed=0
# during exporting Shared folder is removed (temporary) - help recover state before exporting
sharedfolder_was_removed=0

# For nice printing
GREEN="\e[1;32m"
RED="\e[1;31m"
YELLOW="\e[1;33m"
NORMAL="\e[0m"
function green {
    printf "$GREEN$*$NORMAL"
}
function red {
    printf "$RED$*$NORMAL"
}
function yellow {
    printf "$YELLOW$*$NORMAL"
}

# Display help
function usage {
    printf "Desc: the automatic Virtualbox Guests and Vagrant Base Boxes builder\n"
    printf "\n"
    printf "Usage: vbkick ACTION VM_NAME\n"
    printf "\n"
    printf "Available actions:\n"
    printf "\tbuild                 build VM\n"
    printf "\tpostinstall           run postinstall scripts via ssh\n"
    printf "\tvalidate              run validate/feature scripts via ssh\n"
    printf "\texport                export VM and create Vagrant VM_NAME.box\n"
    printf "\tupdate                update VBoxGuestAdditions and run update scripts via ssh\n"
    printf "\tdestroy               destroy VM\n"
    printf "\thelp                  display this help and exit\n"
    printf "\n"
}

# Cmd line parser, take 2 args
function process_args {
    VM="${2}"
    case "$1" in
        "build") build_vm ;;
        "destroy") destroy_vm ;;
        "export") export_vm ;;
        "validate") validate_vm ;;
        "postinstall") lazy_postinstall ;;
        "update") lazy_update ;;
        *) usage; exit ;;
    esac
}

# Help automatically update/maintain value of VBOX_VERSION in given files list
function autoupdate_files_with_vbox_version {
    for file in "${files_to_autoupdate_vbox_version[@]}"; do
        # check whether file exist
        if [ -s "${file}" ]; then
            # example value to update: VBOX_VERSION="4.2.12", but ignore comments
            sed -r -i "/^#/!s/(VBOX_VERSION)=\"([0-9\.]+)\"/\1=\"$vb_version\"/g" "${file}"
        fi
    done
}

# Load definition.cfg config file; it overwrite default settings
function load_definition {
    if [ -s "definition.cfg" ]; then
        # In POSIX mode the '.' and 'source' builtins do not search the current directory
        # for the filename argument if it is not found by searching PATH.
        . "./definition.cfg"
    else 
        printf "Not existing or empty definition.cfg file in `pwd`\n"
        printf "Terminating...\n" >&2
        exit 1
    fi
    autoupdate_files_with_vbox_version
}

# Get virtualbox version
function get_vb_version {
    local version=$(VBoxManage --version) # e.g. 4.2.12r84980
    local version=${version%r*} #e.g. 4.2.12
    printf "${version}\n"
}

# Check whether iso/media dir exist
function prepare_media_dir {
    if [ ! -d "${iso_path}" ]; then
        printf "Creates iso directory\n"
        mkdir "${iso_path}"
    fi
}

# Downloads custom VBoxGuestAdditions if required
function download_guest_additions_media {
    if [ $guest_additions_download -eq 1 ]; then
        prepare_media_dir
        # check whether VBoxGuestAdditions exist
        if [ ! -f "${iso_path}/VBoxGuestAdditions_${vb_version}.iso" ]; then
            local additions_url="http://download.virtualbox.org/virtualbox/${vb_version}/VBoxGuestAdditions_${vb_version}.iso"
            wget --no-check-certificate "${additions_url}" -P "${iso_path}"
        fi
    fi
    # rm useless images
    remove_guest_additions_media
}

# Remove other (not needed) VBoxGuestAdditions from media directory
function remove_guest_additions_media {
    # true is usefull to not fail whole cmd, and return empty string 
    local file_list=$(ls "${iso_path}" | grep "GuestAdditions" | grep -v "${vb_version}" || true)
    # continue only if we have some files to remove
    if [ -n "${file_list}" ]; then
        printf "List of VBoxGuestAdditions files to remove:\n"
        for file in "${file_list}"; do
            printf "${file}\n"
        done
        # to remove files ask about confirmation
        read -r -p "Do you want remove above VBoxGuestAdditions files? [y/N]" ans
        if [[ $ans =~ ^[Yy]$ ]]; then
            for file in "${file_list}"; do
                printf "${file}\n"
                rm -f "${iso_path}/${file}"
            done
        fi
    fi
}

# Prepare installation media
function download_install_media {
    prepare_media_dir
    # check whether iso_file exist
    if [ ! -f "${iso_path}/${iso_file}" ]; then
        # iso_src is empty (not defined)
        if [ -z "${iso_src}" ]; then 
            red "${iso_path}/${iso_file} not exist and iso_src is empty\n"
            exit 1
        fi
        wget --no-check-certificate "${iso_src}" -O "${iso_path}/${iso_file}"
    fi

    # verify iso_src sha256sum
    local get_sha256=$(sha256sum ${iso_path}/${iso_file} | cut -d" " -f 1)
    if [[ "${iso_sha256}" != "${get_sha256}" ]]; then
        yellow "WARNING: SHA256SUM is different then expected !\n"
        read -r -p "Do you want continue? [y/N]" ans
        if [[ ! $ans =~ ^[Yy]$ ]]; then
            exit 1
        fi
    else
        printf "INFO: SHA256SUM:${iso_sha256} is valid.\n"
    fi
}

# Prepare ssh keys
function get_priv_ssh_key {
    # check whether keys dir exist
    if [ ! -d "${ssh_keys_path}" ]; then
        printf "Creates vbkick ssh keys directory\n"
        mkdir "${ssh_keys_path}"
    fi
    # check whether private key exist
    if [ ! -f "${ssh_keys_path}/${ssh_priv_key}" ]; then
        wget --no-check-certificate "${ssh_priv_key_src}" -O "${ssh_keys_path}/${ssh_priv_key}"
    fi
    # change ssh key permissions - too open private key will be ignored
    chmod 600 "${ssh_keys_path}/${ssh_priv_key}"
}

function build_vm {
    # check whether VM already exist
    if [[ `VBoxManage list vms | grep -w "${VM}"` ]]; then
        red "${VM} already exist\n"
        exit 1
    fi
    # load vm description/definition
    load_definition
    # download iso files
    download_install_media
    download_guest_additions_media
    # get ssh private key
    if [ $ssh_keys_enabled -eq 1 ]; then
        get_priv_ssh_key
    fi
    # start simple webserver (in background)
    start_web_server
    # create VM box with given settings
    create_box
    # host ip to connect from guest
    local host_ip=10.0.2.2
    # start VM
    if [ $gui_enabled -eq 1 ]; then
        VBoxManage startvm --type gui "${VM}"  && sleep $boot_wait
    else
        VBoxManage startvm --type headless "${VM}" && sleep $boot_wait
    fi
    # boot VM machine
    for boot_cmd in "${boot_cmd_sequence[@]}"; do
        if [ -z "${boot_cmd}" ]; then 
            continue
        fi
        boot_cmd=$(echo "${boot_cmd}" | sed -r "s/%IP%/$host_ip/g")
        boot_cmd=$(echo "${boot_cmd}" | sed -r "s/%PORT%/$kickstart_port/g")
        boot_cmd=$(echo "${boot_cmd}" | sed -r "s/%NAME%/${VM}/g")
        printf "${boot_cmd}\n"
        # converts string to scancode via external python script
        local boot_cmd_code=$(printf "${boot_cmd}" | convert_2_scancode.py)
        # sends code to VM
        for code in $boot_cmd_code; do
            #printf "${code}\n"
            if [ "${code}" == "wait" ]; then
                #printf "waiting...\n"
                sleep 1
            else
                VBoxManage controlvm "${VM}" keyboardputscancode $code
                sleep 0.01
            fi
        done
        sleep $boot_seq_wait
    done

    # wait until machine will be ready (ssh connection start working) or timeout was reached
    kickstart_monitoring

    # stop webserver
    stop_web_server

    # release install image
    VBoxManage storageattach "${VM}" --storagectl "IDE Controller"\
    --type dvddrive --port 0 --device 0 --medium emptydrive --forceunmount

    exit 0
}

function create_box {
    # register vm
    VBoxManage createvm --name "${VM}" --ostype "${os_type_id}" --register

    # create disk
    local location=$(VBoxManage list  systemproperties | grep "Default machine folder" | cut -d':' -f 2 | sed 's/^ *//g')
    VBoxManage createhd --filename "${location}/${VM}/${VM}.${disk_format}"\
    --size $disk_size --format "${disk_format}" --variant Standard

    # SATA controler - add hard disk
    VBoxManage storagectl "${VM}" --name "SATA Controller"\
    --add sata --hostiocache $hostiocache --sataportcount 1
    VBoxManage storageattach "${VM}" --storagectl "SATA Controller"\
    --port 0 --device 0 --type hdd --medium "${location}/${VM}/${VM}.${disk_format}"

    # IDE controler - add install iso
    VBoxManage storagectl "${VM}" --name "IDE Controller" --add ide
    VBoxManage storageattach "${VM}" --storagectl "IDE Controller"\
    --type dvddrive --port 0 --device 0 --medium "${iso_path}/${iso_file}"
    # IDE controler - add VBoxGuestAdditions iso
    if [ $guest_additions_download -eq 1 ]; then
        # custom VBoxGuestAdditions
        VBoxManage storageattach "${VM}" --storagectl "IDE Controller"\
        --type dvddrive --port 1 --device 0 --medium "${iso_path}/VBoxGuestAdditions_${vb_version}.iso"
    else
        # default VBoxGuestAdditions
        VBoxManage storageattach "${VM}" --storagectl "IDE Controller"\
        --type dvddrive --port 1 --device 0 --medium emptydrive
        VBoxManage storageattach "${VM}" --storagectl "IDE Controller"\
        --type dvddrive --port 1 --device 0 --medium additions
    fi

    # Tuning VM
    # setting cpu's
    VBoxManage modifyvm "${VM}" --cpus $cpu_count
    # setting memory size
    VBoxManage modifyvm "${VM}" --memory $memory_size
    # setting video memory size
    VBoxManage modifyvm "${VM}" --vram $video_memory_size
    # setting bootorder
    VBoxManage modifyvm "${VM}" --boot1 disk --boot2 dvd --boot3 none --boot4 none
    # other settings
    for option in "${vm_options[@]}"; do
        local key="${option%%:*}"
        local value="${option##*:}"
        VBoxManage modifyvm "${VM}" --"${key}" "${value}"
    done

    # ssh NAT mapping
    if [[ ! `VBoxManage showvminfo "${VM}" | grep "vbkickSSH"` ]]; then
        # TODO [LOW]: check whether ssh_host_port is already in use and take other
        VBoxManage controlvm "${VM}" natpf1 "vbkickSSH,tcp,,${ssh_host_port},,${ssh_guest_port}"
    fi

    # add shared folders
    if [ -n "${shared_folder}" ]; then 
        VBoxManage sharedfolder add  "${VM}" --name "${shared_folder}" --hostpath "`pwd`" --automount
    fi
}

# Check whether machine was kickstarted before timeout
function kickstart_monitoring {
    local kickstart_counter=0
    local extra_ssh_options="-o ConnectionAttempts=1 -o ConnectTimeout=1"
    # ssh key authentication enabled
    if [ $ssh_keys_enabled -eq 1 ]; then        
        # create path to ssh private key
        local key_path="${ssh_keys_path}/${ssh_priv_key}"
        printf "\nWaiting for ssh login with user ${ssh_user} to localhost:${ssh_host_port} to work, kickstart_timeout=${kickstart_timeout} sec\n"
        # wait until ssh start working (communication chanel with VM) or kickstart_timeout was reached
        while [[ ! `ssh "${ssh_user}@localhost" -q -t -i ${key_path} -p $ssh_host_port $ssh_options $extra_ssh_options -C "echo"`\
            && $kickstart_counter -le $kickstart_timeout ]]; do
            kickstart_counter=$((kickstart_counter+1))
            printf "."
            sleep 1
        done
        printf "\n"
    else
        # if no ssh key authentication enabled then wait until timeout was reached
        sleep $kickstart_timeout
    fi
}

function destroy_vm {
    # check whether VM already exist
    if [[ ! `VBoxManage list vms | grep -w "${VM}"` ]]; then
        red "${VM} doesn't exist\n"
        exit 1
    fi

    # destroy VM
    printf "Destroy ${VM}\n"
    read -r -p "Are you sure? [y/N]" ans
    if [[ ! $ans =~ ^[Yy]$ ]]; then
        exit 1
    fi

    # check whether VM is running
    if [[ `VBoxManage list runningvms | grep -w "${VM}"` ]]; then
        printf "Poweroff ${VM}\n"
        VBoxManage controlvm "${VM}" poweroff
        sleep 1
    fi

    printf "Destroying...\n"
    VBoxManage unregistervm "${VM}" --delete
    exit 0
}

function export_vm {
    #
    # basic replacement for that vagrant command:
    # vagrant package --base "${VM}" --output "${VM}.box"
    # if more customisation required use: vagrant package (--help)
    #
    # load vm description/definition
    load_definition
    # check whether VM_NAME.box exist in current dir
    if [ -f "${VM}.box" ]; then
        red "${VM}.box already exist in `pwd`\n"
        exit 1
    fi
    # check whether VM exist
    if [[ ! `VBoxManage list vms | grep -w "${VM}"` ]]; then
        red "${VM} doesn't exist\n"
        exit 1
    fi
    # check whether VM is running and shutdown it 
    shutdown

    # clearing previously set port forwarding rules (only if exist)
    if [[ `VBoxManage showvminfo "${VM}" | grep -w "vbkickSSH"` ]]; then
        VBoxManage modifyvm "${VM}" --natpf1 delete "vbkickSSH"
        natmapping_was_removed=1
    fi
    
    # rm shared folder (only if exist)
    if [[ `VBoxManage showvminfo "${VM}" | grep -w 'machine mapping' | grep -w "Name: '${shared_folder}'"` ]]; then
        VBoxManage sharedfolder remove  "${VM}" --name "${shared_folder}"
        sharedfolder_was_removed=1
    fi

    # create tmp_dir for export data
    tmp_dir=$(mktemp -d --tmpdir=.)
    # export VM to tmp_dir
    VBoxManage export "${VM}" --output "${tmp_dir}/box.ovf"
    # get VM MAC Address
    local mac_address=$(VBoxManage showvminfo --details --machinereadable "${VM}"\
    | grep macaddress1 | cut -d"=" -f 2)
    # add Vagrantfile
    printf "Vagrant::Config.run do |config|
    \t# This Vagrantfile is auto-generated by \`vagrant package\` to contain
    \t# the MAC address of the box. Custom configuration should be placed in
    \t# the actual \`Vagrantfile\` in this box.
    \tconfig.vm.base_mac = ${mac_address}
    \rend\n
    \r# Load include vagrant file if it exists after the auto-generated
    \r# so it can override any of the settings
    \rinclude_vagrantfile = File.expand_path(\"../include/_Vagrantfile\", __FILE__)
    \rload include_vagrantfile if File.exist?(include_vagrantfile)\n" > "${tmp_dir}/Vagrantfile"
    # add metadata.json
    printf "{\"provider\":\"virtualbox\"}\n" > "${tmp_dir}/metadata.json"
    # create VM_NAME.box (gzip) file
    cd $tmp_dir && tar -cvzf "${VM}.box" * && cd ..
    mv "${tmp_dir}/${VM}.box" .
    # remove tmp_dir
    rm -rf $tmp_dir
    # help recover some changes made on VM during exporting
    recover_vm_state
    printf "Done: `pwd`/${VM}.box\n"
    exit 0
}

function recover_vm_state {
    # add NAT mapping after exporting - only if exist prev.
    if [ $natmapping_was_removed -eq 1 ]; then
        VBoxManage controlvm "${VM}" natpf1 "vbkickSSH,tcp,,${ssh_host_port},,${ssh_guest_port}"
        natmapping_was_removed=0
    fi
    # add shared folder after exporting - only if exist prev.
    if [ $sharedfolder_was_removed -eq 1 ]; then
        VBoxManage sharedfolder add  "${VM}" --name "${shared_folder}" --hostpath "`pwd`" --automount
        sharedfolder_was_removed=0
    fi
}

function shutdown {
    # ssh key authentication enabled
    if [ $ssh_keys_enabled -eq 1 ]; then        
        # if key not exist then get it
        get_priv_ssh_key
        # create path to ssh private key
        local key_path="${ssh_keys_path}/${ssh_priv_key}"

        # check whether VM is running and exec shutdown_cmd via SSH
        if [[ `VBoxManage list runningvms | grep -w "${VM}"` ]]; then
            printf "Shutting down ${VM} "
            ssh "${ssh_user}@localhost" -q -t -i ${key_path} -p $ssh_host_port $ssh_options -C "${shutdown_cmd}"
        fi

        # wait until VM is down or shutdown_timeout was reached
        local shutdown_counter=0
        while [[ `VBoxManage list runningvms | grep -w "${VM}"` && $shutdown_counter -le $shutdown_timeout ]]; do
            shutdown_counter=$((shutdown_counter+1))
            printf "."
            sleep 1
        done
    fi
    
    # check whether VM is still running, if so poweroff it using hard way.
    if [[ `VBoxManage list runningvms | grep -w "${VM}"` ]]; then
        VBoxManage controlvm "${VM}" poweroff
        printf "\n${VM} was powered off.\n"
        sleep 5
    else
        printf "\n${VM} was shutdown cleanly.\n"
        sleep 5
    fi
}

function validate_vm {
    #
    # test should be smart enough to check what I really want to test
    # e.g. If I don't need chef, don't test whether I have chef
    #
    # load vm description/definition
    load_definition
    # exec scripts on VM Guest via ssh
    ssh_exec ${#validate_transport[@]} "${validate_transport[@]}" "${validate_launch[@]}" 1
    exit 0
}

function lazy_postinstall {
    #todo [LOW]: attach and release  VBoxGuestAdditions image to not break virtualbox.sh postinstall script
    # load vm description/definition
    load_definition
    # exec scripts on VM Guest via ssh
    ssh_exec ${#postinstall_transport[@]} "${postinstall_transport[@]}" "${postinstall_launch[@]}" 1
    exit 0
}

function lazy_update {
    # load vm description/definition
    load_definition
    # check whether VM is running, must be running 
    if [[ ! `VBoxManage list runningvms | grep -w "${VM}"` ]]; then
        red "${VM} is not running...\n"
        exit 1
    fi
    
    # get current guest version
    if [[ `VBoxManage guestproperty enumerate "${VM}" | grep "GuestAdd/Version"` ]]; then
        # guest already exist, get current version
        local guest_version=$(VBoxManage guestproperty get "${VM}" "/VirtualBox/GuestAdd/Version" | cut -f 2 -d " ")
    else
        # guest doesn't exist
        local guest_version=""
    fi

    # check whether we need update or install VBoxGuestAdditions
    if [ "${vb_version}" != "${guest_version}" ]; then
        # todo [LOW]: use Storage Controller Name (1) and type to find controller name
        # check whether "IDE Controller (0, 0)" and "IDE Controller (1, 0)" exist - require to attach iso and create /dev/sr1
        if [[ ! `VBoxManage showvminfo "${VM}" | grep -w "IDE Controller (0, 0)"` ]] || \
            [[ ! `VBoxManage showvminfo "${VM}" | grep -w "IDE Controller (1, 0)"` ]]; then
            red "\"IDE Controller (0, 0)\" (Primary Master) or \"IDE Controller (1, 0)\" (Secondary Master) for \"${VM}\" doesn't exist.\n"
            red "\"IDE Controller\" is ide controller name used by vbkick.\n"
            red "More: 'VBoxManage showvminfo \"${VM}\" | grep -w \"Controller\"'\n"
            red "\nTo create proper controller use:\n"
            red "'VBoxManage storagectl \"${VM}\" --name \"IDE Controller\" --add ide'\n"
            red "'VBoxManage storageattach \"${VM}\" --storagectl \"IDE Controller\" --type dvddrive --port 0 --device 0 --medium emptydrive'\n"
            red "'VBoxManage storageattach \"${VM}\" --storagectl \"IDE Controller\" --type dvddrive --port 1 --device 0 --medium emptydrive'\n"
            red "\nTo do this \"${VM}\" must be shutdown !!! \nRemember - VM Guest may have only one ide controller.\n"
            exit 1
        fi
        # Attach new VBoxGuestAdditions to install
        # vbkick always use port=1 and device=0 for Guest Additions (Secondary Master)
        # Note: which cd-rom device use on guest? /dev/sr1 or /dev/sr0 if "IDE Controller (0, 0)" not exist. If is "Empty" then still exist.
        # vbkick creates VM with two SCSI CD-ROM devices: first - install iso, second - VBoxGuestAdditions iso.
        if [ $guest_additions_download -eq 1 ]; then
            # custom VBoxGuestAdditions
            download_guest_additions_media
            VBoxManage storageattach "${VM}" --storagectl "IDE Controller"\
            --type dvddrive --port 1 --device 0 --medium "${iso_path}/VBoxGuestAdditions_${vb_version}.iso" --forceunmount
        else
            # default VBoxGuestAdditions
            remove_guest_additions_media
            VBoxManage storageattach "${VM}" --storagectl "IDE Controller"\
            --type dvddrive --port 1 --device 0 --medium additions --forceunmount
            # Note: howto check default location for guest additions:
            # `VBoxManage list  systemproperties | grep -w "Default Guest Additions ISO" | cut -f 2 -d ":"`
            # example output: /usr/share/virtualbox/
        fi
        # Note: Guest OS (Linux) does not support automatic Guest Additions updating: 
        # VBoxManage guestcontrol <vmname>|<uuid> updateadditions
        # Manuall Guest Additions update/installation.
        if [ $ssh_keys_enabled -eq 1 ]; then        
            # if key not exist then get it
            get_priv_ssh_key
            # create path to ssh private key
            local key_path="${ssh_keys_path}/${ssh_priv_key}"
            # true to ignore fails because, install cmd may fail when no X on guest OS: "Installing the Window System drivers ...fail"
            ssh "${ssh_user}@localhost" -t -i "${key_path}" -p $ssh_host_port $ssh_options -C "${manuall_update_guest_additions}" || true
        fi
        # Cleaning
        # todo [LOW]: release VBoxGuestAdditions image; it break virtualbox.sh postinstall script
    else
        green "VBoxGuestAdditions on ${VM} is up-to-date\n"
    fi

    # Run other update scripts on VM Guest via ssh
    ssh_exec ${#update_transport[@]} "${update_transport[@]}" "${update_launch[@]}" 0
    exit 0
}

function ssh_exec {
    #
    # transport scripts to VM Guest via SCP and exec them via SSH
    #
    # get number of transport files/directories; transport array length
    local pos=$1
    shift
    # get transport array; everything to $pos
    local transport=("${@:1:$pos}")
    shift $pos
    # get launch array; everything but last arg
    local len=$(($#-1))
    local launch=("${@:1:$len}")
    shift $len
    # get last arg
    # useful for running tests on destination machine, tests don't stop after first ERROR
    local accept_ssh_command_fail=$1

    # check whether VM is running 
    if [[ ! `VBoxManage list runningvms | grep -w "${VM}"` ]]; then
        red "${VM} is not running...\n"
        exit 1
    fi

    # checking port forwarding (if no proper rules, try add new one for NAT mapping)
    if [[ ! `VBoxManage showvminfo "${VM}" | grep "NIC 1" | grep "host port = ${ssh_host_port}"\
        | grep "guest port = ${ssh_guest_port}"` ]]; then
        printf "NAT mapping - enable ssh port forwarding\n"
        VBoxManage controlvm "${VM}" natpf1 "vbkickSSH,tcp,,${ssh_host_port},,${ssh_guest_port}"
    fi

    # ssh key authentication enabled
    if [ $ssh_keys_enabled -eq 1 ]; then        
        # if key not exist then get it
        get_priv_ssh_key
        # create path to ssh private key
        local key_path="${ssh_keys_path}/${ssh_priv_key}"

        # transport scripts to guest
        for pkt in "${transport[@]}"; do
            if [ -z "${pkt}" ]; then 
                continue #consider break
            fi
            # check whether pkt is file or dir
            if [[ -d "${pkt}" ]]; then
                # pkt is directory
                scp -q -P $ssh_host_port -i "${key_path}" $ssh_options -r "${pkt}" "${ssh_user}@localhost:~${ssh_user}"
            elif [[ -f "${pkt}" ]]; then
                # pkt is file
                scp -q -P $ssh_host_port -i "${key_path}" $ssh_options "${pkt}" "${ssh_user}@localhost:~${ssh_user}"
            else
                # pkt is neither file nor directory
                printf "${pkt} is neither file nor directory\n"
                exit 1
            fi
        done

        # run commands via ssh
        for cmd in "${launch[@]}"; do
            if [ -z "${cmd}" ]; then 
                continue #consider break
            fi
            printf "Exec: ${cmd}\n"
            if [ $accept_ssh_command_fail -eq 0 ]; then
                # fail is not accepted
                ssh -q "${ssh_user}@localhost" -t -i ${key_path} -p $ssh_host_port $ssh_options -C "${cmd}"
            else
                # fail is accepted
                ssh -q "${ssh_user}@localhost" -t -i ${key_path} -p $ssh_host_port $ssh_options -C "${cmd}" || true
            fi
        done
        
        # clean after scp by rm transported media/scripts
        if [ $clean_transported -eq 1 ]; then
            for pkt in "${transport[@]}"; do
                if [ -z "${pkt}" ]; then 
                    continue
                fi
                ssh -q "${ssh_user}@localhost" -t -i ${key_path} -p $ssh_host_port $ssh_options -C "cd ~${ssh_user} && rm -rf ${pkt}"
            done
        fi
    fi
    # todo [LOW]: if ssh keys authentication is not enabled try login using password (ask about passwd ?)
    # (root, user, sshpass, expect, VBoxManage guestcontrol)(same for shutdown, kickstart_monitoring)
}

function start_web_server {
    # check whether port is not used by other proc
    if [[ `nc -z localhost $kickstart_port` ]]; then
        red "$kickstart_port port is already in use\n"
        # TODO [LOW]: choose next webserver port if present is in use from kickstart_port list, 
        # and update current_kickstart_port - this not working with injection method (list of files to update ?)
        exit 1
    fi
    # start simple webserver serving files in background
    python -m SimpleHTTPServer $kickstart_port &
    # get the pid already spawned process, to kill it later
    web_pid=$!
    sleep 2
    # check whether web server was really started
    if [[ ! `nc -z localhost $kickstart_port` ]]; then
        printf "webserver was not started\n"
        exit 1
    fi
    # update webserver_status variable
    webserver_status=1
}

function stop_web_server {
    # check whether webserver is running
    if [ $webserver_status -ne 0 ]; then
        printf "Stopping webserver...\n"
        # with "set -e -E" if kill command fail then ERR trap is processing 
        # simply execution of function is not continued
        webserver_kill_status=1
        kill $web_pid
        webserver_kill_status=0
        # kill command is sucessfull when SIGTERM is sent to running process
        # not when child process was really killed
        if [ ! `ps -ef | grep "python -m SimpleHTTPServer $kickstart_port" | grep -v grep` ]; then
            printf "INFO: webserver was stopped\n"
        else
            printf "WARNING: problem with stopping webserver. Kill proces manually\n"
            ps -ef | grep "python -m SimpleHTTPServer $kickstart_port" | grep -v grep
        fi
        # update webserver_status variable
        webserver_status=0
    fi
}

# (signals and error handler) - cleaning after ctr-c, etc.
function clean_up {
    printf "INFO: Signal/Error handler - cleanup before exiting...\n"
    if [ $webserver_kill_status -eq 0 ]; then
        # stop webserver (only if stop_web_server function didn't fail previuosly)
        stop_web_server
    else
        # previuosly executed stop_web_server function fail in killing $web_pid
        printf "WARNING: problem with killing webserver (proc ${web_pid}). Kill proces manually\n"
    fi
    # help recover some changes made on VM during exporting
    recover_vm_state
    # clean tmp_dir if exist
    if [ -d $tmp_dir ]; then
        rm -rf $tmp_dir
    fi
    exit 1
}

## MAIN ##
# exactly 2 Args required - ACTION VM_NAME
if [ $# -ne 2 ]; then
    usage
    exit 1
fi

# check whether Virtualbox is installed - VBoxManage command exist
if [[ ! `which VBoxManage 2>/dev/null` ]]; then
    printf "VBoxManage command not exist - install Virtualbox or check your PATH\n"
    exit 1
fi
vb_version=$(get_vb_version)
# signals and error handler
trap clean_up SIGHUP SIGINT SIGTERM ERR
process_args "${1}" "${2}"
