#!/bin/bash

# The MIT License - https://github.com/wilas/vbkick/blob/master/LICENSE

# Helps build Virtualbox guest VMs and Vagrant base boxes.

# Secure bash
# More about options: http://wiki.bash-hackers.org/commands/builtin/set
# treat unset variables as an error
set -u;
# exit when cmd fail (use ERR trap for clean exit)
set -e; set -E;
# fail the entire pipeline if any part of it fails
set -o pipefail;
# debug mode
#set -x;
# http://mywiki.wooledge.org/glob
shopt -s failglob;
# enable POSIX mode
# http://www.gnu.org/software/bash/manual/html_node/Bash-POSIX-Mode.html
set -o posix

# VM default settings - basic
hostiocache="on"
cpu_count=1
memory_size=512
disk_size=(10140)
disk_format="vdi"
video_memory_size=10
# available boot devices: none|floppy|dvd|disk|net
# there are four slots, if priovided less than 4, extra slots set to none
# if provided more than 4, extra values are droped
boot_order=("disk" "dvd")
# default nic type: Intel PRO/1000 MT Desktop (82540EM); recommended - virtio
# more to choose Am79C970A|Am79C973|82540EM|82543GC|82545EM|virtio
# http://www.virtualbox.org/manual/ch06.html#nichardware
nic_type="82540EM"
# list of VM options: ("option1:value" "option2:value")
vm_options=("ioapic:on")
# list of VM extradata to set: ("extradata:value" "extradata:value")
vm_extradata=("")
# by default gui enabled unless the VirtualBox GUI is missing
gui_enabled=1
if ! command -v VirtualBox >/dev/null 2>&1; then
    gui_enabled=0
fi
# by default add one shared folder - to disable: shared_folders=("")
shared_folders=("vbkick:%PWD%:automount")
# by default no extra ports is mapping
extra_ports=("")

# Guest Additions default settings
# set to 0 to not attach VBoxGuestAdditions iso to guest
guest_additions_attach=1
# path where guest_additions should be download, if empty then not download custom VBoxGuestAdditions to host, use default one
guest_additions_path=""

# Boot default settings
#boot_file -> required option, fail if not in definition
#boot_file_src -> required option, fail if not in definition
# type of boot media e.g.: hdd, dvddrive; by default dvddrive
boot_file_type="dvddrive"
# default path for src media needed to create destination boot_file
boot_file_src_path="iso"
# by default checksum is empty - checksum is not check
boot_file_src_checksum=""
# default cheksum type is sha256
boot_file_checksum_type="sha256"
# by default unpacke is not needed
boot_file_unpack_cmd=""
# where is the path and the filename after unpack
boot_file_unpack_name=""
# is boot_file_src raw image and need to be converted
boot_file_convert_from_raw=0
# whether use cp or mv when boot_file is created form boot_file_src_file;
# mv mean don't keep boot_file_src_file; keep only boot_file; by default 0 - use mv
keep_boot_src_file=0
# default time before boot_cmd_sequence start
boot_wait=10
# list of boot_cmd: ("cmd1" "cmd2" "cmd3")
boot_cmd_sequence=("")
# default number of second wait between each boot_cmd
boot_seq_wait=1
# default webserver port to serve kickstart files
kickstart_port=7122
# default max webserver live time
kickstart_timeout=7200
# do not start local webserver, by default 0 - mean start webserver to serve files from current dir.
webserver_disabled=0

# SSH default settings (veeded to run vbkick validate and/or lazy_posinstall)
# by default use ssh keys
ssh_keys_enabled=1
# default user
ssh_user="vbkick"
# default user password - not use when ssh_keys authentication is enabled
ssh_password="vbkick"
# default path to ssh keys
ssh_keys_path="keys"
# default private key name
ssh_priv_key="vbkick_key"
# default auto-download path
ssh_priv_key_src="https://raw.github.com/wilas/vbkick/master/keys/vbkick_key"
# default ssh host port
ssh_host_port=2222
# default (22) ssh guest port to forwarding
ssh_guest_port=22
# default "vbkickSSH"
ssh_port_name="vbkickSSH"
# default extra ssh and scp options
# UserKnownHostsFile - database file to use for storing the user host keys
# StrictHostKeyChecking - if "no" then automatically add new host keys to the host key database file
# you may consider editing ssh config: http://superuser.com/questions/141344/ssh-dont-add-hostkey-to-known-hosts
ssh_options="-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o NumberOfPasswordPrompts=1"

# Lazy Postinstall default settings
# list of files and directories to transport to guest
postinstall_transport=("")
# list of postinstall commands
postinstall_launch=("")

# Validate default settings
# list of files and directories to transport to guest
validate_transport=("")
# list of validate commands
validate_launch=("")

# Lazy Update default settings
# list of files and directories to transport to guest
update_transport=("")
# list of update commands
update_launch=("")

# Clean
# list of files to autoupdate VBOX_VERSION value
files_to_autoupdate_vbox_version=("")
# rm or not already transported via SCP files/directories (from postinstall, validate)
clean_transported=0
# nice for OS shutdown command, if not specify acpipowerbutton will be used
shutdown_cmd=""
# when timeout is reached and VM is still running, hard poweroff is used
shutdown_timeout=20

# Other global variables - do not use it in definition file (will be overwrite during program runtime)
# name of global "private" variables should start with underscore
# virtual machine name
VM=""
# 0 - webserver is not running or kill isn't able to stop it
_webserver_state=0
# 0 - webserver was killed cleanly or we didn't try kill it yet
_webserver_kill_cmd_state=0
# during exporting tmp directory is created
_tmp_dir=""
# during creation VM may be temporary in inconsistent state
# e.g. not all ports mapping, options etc. were setup
# this flag is used to make sure that vm was created completely or not at all
_vm_creation_state=0
# during exporting NAT mapping is removed (temporary) - help recover state before exporting
_ssh_natmapping_was_removed=0
# during exporting shared folders are removed (temporary) - help recover state before exporting
_sharedfolders_removed_ptr=0
# during exporting extra ports are removed (temporary) - help recover state before exporting
_extraports_removed_ptr=0

# For nice printing
# name of constants should be uppercase
GREEN="\e[1;32m"
RED="\e[1;31m"
YELLOW="\e[1;33m"
NORMAL="\e[0m"
log_info() {
    printf "[INFO] ${*}\n"
}
log_ginfo() {
    printf "${GREEN}[INFO] ${*}${NORMAL}\n"
}
log_warning() {
    printf "${YELLOW}[WARNING] ${*}${NORMAL}\n"
}
log_error() {
    printf "${RED}[ERROR] ${*}${NORMAL}\n" >&2
}

# Display help
usage() {
    printf "Description: the automatic Virtualbox Guests and Vagrant Base Boxes builder\n"
    printf "\n"
    printf "Usage: vbkick <command> <VM_NAME> [<args>]\n"
    printf "\tversion               Print the version and exit\n"
    printf "\thelp                  Print this help\n"
    printf "\n"
    printf "Common commands:\n"
    printf "\tbuild                 Build the new VM\n"
    printf "\tpostinstall           Run postinstall scripts via SSH\n"
    printf "\tvalidate              Run validate scripts via SSH\n"
    printf "\tupdate                Run update scripts via SSH\n"
    printf "\texport                Exports the VM and creates a Vagrant box - VM_NAME.box\n"
    printf "\tdestroy               Shut down and deletes the VM\n"
    printf "\tssh                   Connect to the VM via SSH\n"
    printf "\ton                    Turn on the VM\n"
    printf "\tshutdown              Shut down the VM\n"
    printf "\tclone                 Clone the VM\n"
    printf "\tlssnap                List all snapshots for a given VM\n"
    printf "\tsnap                  Take a new VM snapshot\n"
    printf "\tresnap                Restore the VM snapshot\n"
    printf "\tdelsnap               Delete the VM snapshot\n"
    printf "\tlist                  List all VirtualBox machines with the state\n"
    printf "\n"
    printf "For help on any individual command run 'vbkick <command> -h'\n"
    printf "\n"
}

context_usage(){
    case "${1}" in
        "build")
            printf "Usage: vbkick build VM_NAME <definition_file>\n"
            printf "If no definition file specify 'definition.cfg' is used.\n" ;;
        "destroy")
            printf "Usage: vbkick destroy VM_NAME\n" ;;
        "export")
            printf "Usage: vbkick export VM_NAME <definition_file>\n"
            printf "If no definition file specify 'definition.cfg' is used.\n" ;;
        "validate")
            printf "Usage: vbkick validate VM_NAME <definition_file>\n"
            printf "If no definition file specify 'definition.cfg' is used.\n" ;;
        "postinstall")
            printf "Usage: vbkick postinstall VM_NAME <definition_file>\n"
            printf "If no definition file specify 'definition.cfg' is used.\n" ;;
        "update")
            printf "Usage: vbkick update VM_NAME <definition_file>\n"
            printf "If no definition file specify 'definition.cfg' is used.\n" ;;
        "ssh")
            printf "Usage: vbkick ssh VM_NAME <definition_file>\n"
            printf "If no definition file specify 'definition.cfg' is used.\n" ;;
        "on")
            printf "Usage: vbkick on VM_NAME\n" ;;
        "shutdown")
            printf "Usage: vbkick shutdown VM_NAME <definition_file>\n"
            printf "If no definition file specify 'definition.cfg' is used.\n" ;;
        "clone")
            printf "Usage: vbkick clone VM_NAME <clone_name>\n"
            printf "If no clone name specify default one will be used - {VM_NAME}-clone{NR},\n"
            printf "where {NR} is the next available number.\n" ;;
        "snap")
            printf "Usage: vbkick snap VM_NAME <snapshot_name>\n"
            printf "If no snapshot name specify default one will be used - {VM_NAME}-snap{NR},\n"
            printf "where {NR} is the next available number.\n" ;;
        "resnap")
            printf "Usage: vbkick resnap VM_NAME <snapshot_name>\n"
            printf "If no snapshot name specify, restore to the current snapshot.\n" ;;
        "delsnap")
            printf "Usage: vbkick delsnap VM_NAME <snapshot_name>\n"
            printf "If no snapshot name specify, delete the current snapshot.\n" ;;
        "lssnap")
            printf "Usage: vbkick lssnap VM_NAME\n" ;;
        "list")
            printf "Usage: vbkick list\n" ;;
        *) usage; exit ;;
    esac
}

process_2_args() {
    # 2 args are required, 3 may be optional
    if [[ "${2}" == "-h" ]] || [[ "${3:-}" == "-h" ]]; then
        context_usage "${1}"
        exit 0
    fi
    VM="${2}"
    case "${1}" in
        "build") build_vm "${3:-}" ;;
        "destroy") destroy_vm ;;
        "export") export_vm "${3:-}" ;;
        "validate") validate_vm "${3:-}" ;;
        "postinstall") lazy_postinstall "${3:-}" ;;
        "update") lazy_update "${3:-}" ;;
        "ssh") lazy_ssh "${3:-}" ;;
        "on") turn_on ;;
        "shutdown") turn_off "${3:-}" ;;
        "clone") make_clone "${3:-}" ;;
        "snap") take_snapshot "${3:-}" ;;
        "resnap") restore_snapshot "${3:-}" ;;
        "delsnap") delete_snapshot "${3:-}" ;;
        "lssnap") list_snapshots ;;
        *) usage; exit ;;
    esac
}

process_1_args() {
    # 1 arg is required
    case "${1}" in
        "list") list_all_vms ;;
        "version") prog_version ;;
        *) usage; exit ;;
    esac
}

#@action
prog_version(){
    printf "0.7.0-dev\n"
    exit 0
}

#@action
list_all_vms(){
    local lc_vm
    local lc_state
    #list all vms and remove trailing spaces from the lc_vm name
    VBoxManage list vms | cut -f 1 -d'{' | sed 's/\s*$//g' | while read -r lc_vm; do
        # get the pure lc_vm name: "aa bb" -> aa bb
        lc_vm="${lc_vm//\"/}"
        # Example showvminfo output: "State:           powered off (since 2014-04-28T00:16:26.000000000)"
        # get only the state value and trim leading and trailing spaces
        lc_state=$(VBoxManage showvminfo "${lc_vm}" | grep State: | cut -d' ' -f 2- | cut -d'(' -f 1 | sed 's/\s*$//g;s/^\s*//g')
        printf "${lc_vm}:${lc_state}\n"
    done
    exit 0
}

# Help automatically update/maintain value of VBOX_VERSION in given files list
autoupdate_files_with_vbox_version() {
    local file
    for file in "${files_to_autoupdate_vbox_version[@]}"; do
        # check whether file is an empty string
        if [[ -z "${file}" ]]; then
            continue
        fi
        # check whether file exist
        if [[ -s "${file}" ]]; then
            # example value to update: VBOX_VERSION="4.2.12", but ignore comments
            sed -r -i "/^#/!s/(VBOX_VERSION)=\"([0-9\.]+)\"/\1=\"${_vb_version}\"/g" "${file}"
        else
            printf "VBOX_VERSION=\"${_vb_version}\"\n" > "${file}"
            printf "export VBOX_VERSION" >> "${file}"
        fi
    done
}

depend_check() {
    local dep_cmd="${1}"
    local dep_name="${2}"
    # check whether dep_name is installed - dep_cmd command exist
    if ! command -v ${dep_cmd} >/dev/null 2>&1; then
        log_error "${dep_cmd} command doesn't exist - install '${dep_name}' to continue."
        return 1
    fi
}

dependencies_check() {
    depend_check "VBoxManage" "Virtualbox"
    depend_check "curl" "curl"
    depend_check "ssh" "ssh-client (e.g. openssh-client)"
    depend_check "scp" "scp-client (e.g. openssh-client)"
    depend_check "python" "python"
    depend_check "bash" "bash"
    depend_check "openssl" "openssl"
    depend_check "sed" "sed"
    depend_check "grep" "grep"
    depend_check "cut" "coreutils"
    depend_check "sort" "coreutils"
    depend_check "tail" "coreutils"
}

check_required_options() {
    local opts=("boot_file" "boot_file_src" "os_type_id")
    local opt
    for opt in "${opts[@]}"; do
        if [[ -z "${!opt+x}" ]]; then
            log_error "Required ${opt} option is not defined."
            return 1
        fi
    done
}

# Load definition.cfg config file; it overwrite default settings
load_definition() {
    # definition.cfg is a default definition file
    local definition_fname="${1:-definition.cfg}"
    if [[ -s "${definition_fname}" ]]; then
        # In POSIX mode the '.' and 'source' builtins do not search the current directory
        # for the filename argument if it is not found by searching PATH.
        log_info "Loading \"${definition_fname}\" definition..."
        . "./${definition_fname}"
    else
        log_error "Not existing or empty \"${definition_fname}\" file in $(pwd). Terminating..."
        return 1
    fi
    check_required_options
    autoupdate_files_with_vbox_version
}

# Get virtualbox version
get_vb_version() {
    local version=$(VBoxManage --version) # e.g. 4.2.12r84980
    local pos=$(expr "${version}" : '[0-9.]\+')
    version=${version:0:${pos}} #e.g. 4.2.12
    printf "${version}"
}

is_present() {
    local pattern="${1:-\"${VM}\"}"
    VBoxManage list vms | grep -qw "${pattern}"
}

is_running() {
    VBoxManage showvminfo "${VM}" | grep -q "State:\s\+running"
}

is_powered_off() {
    VBoxManage showvminfo "${VM}" | grep -q "State:\s\+powered off"
}

is_paused() {
    VBoxManage showvminfo "${VM}" | grep -q "State:\s\+paused"
}

is_alive() {
    # Alive machine may be in paused|running state
    # Useful to change state: VBoxManage controlvm "${VM}" pause|resume
    local pattern="${1:-\"${VM}\"}"
    VBoxManage list runningvms | grep -qw "${pattern}"
}

is_port_used() {
    local port_nr="${1}"
    # () is useful to be silent
    (printf "" > /dev/tcp/127.0.0.1/${port_nr}) 2>/dev/null
}

is_port_present() {
    local port_name="${1}"
    VBoxManage showvminfo "${VM}" | grep -w 'guest port' | grep -qw "${port_name}"
}

is_shared_folder_present() {
    local folder_name="${1}"
    VBoxManage showvminfo "${VM}" | grep -w 'machine mapping' | grep -qw "Name: '${folder_name}'"
}

is_snapshot_present() {
    local snap_name="${1}"
    VBoxManage snapshot "${VM}" list --machinereadable | grep -w "^SnapshotName\|SnapshotUUID" | grep -qw "${snap_name}"
}

has_snapshots() {
    VBoxManage snapshot "${VM}" list --machinereadable | grep -qw "^SnapshotName"
}

# checks whether port is not used by other proc
check_port_usage() {
    local port_nr="${1}"
    local port_message="${2}"
    if is_port_used ${port_nr}; then
        log_error "${port_nr} port (${port_message}) is already used by an other process."
        return 1
    fi
}

# Check whether given directory exist
prepare_path() {
    local path="${1}"
    local mkdir_path="${2}"
    # Process special variables in path definition e.g. path="%VBOXFOLDER%/%NAME%"
    local location=$(VBoxManage list  systemproperties | grep "Default machine folder" | cut -d':' -f 2 | sed 's/^\s*//g')
    path=${path//%SRCPATH%/${boot_file_src_path}}
    path=${path//%VBOXFOLDER%/${location}}
    path=${path//%PWD%/$(pwd)}
    # get homedir - $(getent passwd UID) doesn't work for MacOS; $HOME is less portable than ~
    path=${path//%HOME%/~}
    path=${path//%NAME%/${VM}}
    # expand a special variable - e.g. tilde (~) and
    # strips out > characters which could clobber a file during the eval
    path=$(eval echo "${path//>}")
    # Creates dir if necessary
    if [[ ${mkdir_path} -eq 1 ]] && [[ ! -z "${path}" ]] && [[ ! -d "${path}" ]]; then
        mkdir -p "${path}"
    fi
    # Return path
    printf "${path}"
}

curl_safe() {
    local src="${1}"
    local dest="${2}"
    local statuscode=$(curl -Lkfw "%{http_code}\n" "${src}" -o "${dest}")
    if [[ ${statuscode} -ne 200 ]]; then
        log_error "${src} status code is ${statuscode}. Terminating..."
        clean_up
    fi
}

# Downloads custom VBoxGuestAdditions if required
download_guest_additions_media() {
    if [[ -z "${guest_additions_path}" ]]; then
        # nothing to do
        return
    fi
    guest_additions_path=$(prepare_path "${guest_additions_path}" 1)
    # check whether VBoxGuestAdditions exist
    if [[ ! -f "${guest_additions_path}/VBoxGuestAdditions_${_vb_version}.iso" ]]; then
        local additions_url="http://download.virtualbox.org/virtualbox/${_vb_version}/VBoxGuestAdditions_${_vb_version}.iso"
        curl_safe "${additions_url}" "${guest_additions_path}/VBoxGuestAdditions_${_vb_version}.iso"
    fi
    # rm useless images
    remove_guest_additions_media
}

# Remove other (not needed) VBoxGuestAdditions from media directory
remove_guest_additions_media() {
    if [[ -z "${guest_additions_path}" ]]; then
        # nothing to do
        return
    fi
    guest_additions_path=$(prepare_path "${guest_additions_path}" 0)
    # true is use to not fail whole cmd, and return empty string
    local file_list=$(ls "${guest_additions_path}" | grep "GuestAdditions" | grep -v "${_vb_version}" || true)
    # continue only if we have some files to remove
    if [[ -z "${file_list}" ]]; then
        return
    fi
    log_info "List of VBoxGuestAdditions files to remove:"
    local file
    for file in ${file_list}; do
        printf "${guest_additions_path}/${file}\n"
    done
    # to remove files ask about confirmation
    local ans
    read -r -p "Do you want remove above VBoxGuestAdditions files? [y/N]" ans
    if [[ ${ans} =~ ^[Yy]$ ]]; then
        for file in ${file_list}; do
            printf "${guest_additions_path}/${file}\n"
            rm -f "${guest_additions_path}/${file}"
        done
    fi
}

# Prepare installation/boot media
download_boot_media() {
    local boot_file_path=$(dirname "${boot_file}")
    local boot_file_name=$(basename "${boot_file}")
    boot_file_path=$(prepare_path "${boot_file_path}" 1)
    boot_file="${boot_file_path}/${boot_file_name}"

    # the temporary name for boot_file is last part from boot_file_src
    local tmp_name=$(basename "${boot_file_src}")
    boot_file_src_path=$(prepare_path "${boot_file_src_path}" 1)
    local boot_file_src_file="${boot_file_src_path}/${tmp_name}"

    # check whether boot file exist
    if [[ -f "${boot_file}" ]]; then
        # if boot_file is the same as boot_file_src_file then we can verify checksum
        # Note: In definition provided is checksum for the boot_file_src which may be a different
        # than destination boot_file
        if [[ "${boot_file}" == "${boot_file_src_file}" ]]; then
            verify_boot_media_checksum "${boot_file}"
        fi
        # file exist, nothing to do
        return
    fi

    # boot_file_src is empty (not defined)
    if [[ -z "${boot_file_src}" ]]; then
        log_error "${boot_file} not exist and boot_file_src is empty"
        return 1
    fi

    # check whether boot_file_src exist
    if [[ ! -f "${boot_file_src_file}" ]]; then
        curl_safe "${boot_file_src}" "${boot_file_src_file}"
    fi
    verify_boot_media_checksum "${boot_file_src_file}"

    # process unpack
    if [[ ! -z "${boot_file_unpack_cmd}" ]]; then
        unpack_boot_media
        local boot_file_src_file="${boot_file_unpack_name}"
    fi

    deploy_boot_media_file "${boot_file_src_file}"
}

verify_boot_media_checksum(){
    local boot_file_src_file="${1}"
    # verify boot_file_src checksum if boot_file_src_checksum is provided
    if [[ -z "${boot_file_src_checksum}" ]]; then
        return
    fi
    local get_checksum=$(openssl "${boot_file_checksum_type}" "${boot_file_src_file}" | cut -d" " -f 2)
    if [[ "${boot_file_src_checksum}" != "${get_checksum}" ]]; then
        log_warning "CHECKSUM is different than expected !"
        local ans
        read -r -p "Do you want continue? [y/N]" ans
        if [[ ! ${ans} =~ ^[Yy]$ ]]; then
            return 1
        fi
    else
        log_info "CHECKSUM:${boot_file_src_checksum} is valid."
    fi
}

unpack_boot_media(){
    # check whether boot_file_unpack_name is empty if so then error
    if [[ -z "${boot_file_unpack_name}" ]]; then
        log_error "boot_file_unpack_name is empty, but boot_file_unpack_cmd is specify"
        return 1
    fi
    # prepare path - this is full path, must already exist in filesystem
    boot_file_unpack_name=$(prepare_path "${boot_file_unpack_name}" 0)
    # check whether boot_file_unpack_name exist - if not then run unpack cmd
    if [[ ! -f "${boot_file_unpack_name}" ]]; then
        # prepare and run unpack cmd
        boot_file_unpack_cmd=$(prepare_path "${boot_file_unpack_cmd}" 0)
        log_info "${boot_file_unpack_cmd}"
        eval "${boot_file_unpack_cmd}"
    fi
}

deploy_boot_media_file(){
    local boot_file_src_file="${1}"
    # process convert from raw if necessary
    if [[ ${boot_file_convert_from_raw} -eq 1 ]]; then
        VBoxManage convertfromraw "${boot_file_src_file}" "${boot_file}" --format "${disk_format}"
        if [[ ${keep_boot_src_file} -eq 0 ]]; then
            rm -f "${boot_file_src_file}"
        fi
    else
        # check whether full path to boot_file_src_file is same as boot_file and boot_file was already created
        if [[ -f "${boot_file}" ]]; then
            return
        fi
        # check whether cp or mv; mv mean don't keep boot_file_src_file; keep only boot_file
        if [[ ${keep_boot_src_file} -eq 0 ]]; then
            mv -f "${boot_file_src_file}" "${boot_file}"
        else
            cp "${boot_file_src_file}" "${boot_file}"
        fi
    fi
}

# Prepare ssh keys
get_priv_ssh_key() {
    # check whether keys dir exist
    if [[ ! -d "${ssh_keys_path}" ]]; then
        log_info "Creates vbkick ssh keys directory"
        mkdir "${ssh_keys_path}"
    fi
    # check whether private key exist
    if [[ ! -f "${ssh_keys_path}/${ssh_priv_key}" ]]; then
        curl_safe "${ssh_priv_key_src}" "${ssh_keys_path}/${ssh_priv_key}"
    fi
    # change ssh key permissions - too open private key will be ignored
    chmod 600 "${ssh_keys_path}/${ssh_priv_key}"
}

#@action
build_vm() {
    # check whether VM already exist
    if is_present; then
        log_error "'${VM}' already exist"
        exit 1
    fi
    # load vm description/definition
    local definition_fname="${1:-}"
    load_definition "${definition_fname}"
    # get ssh private key
    if [[ ${ssh_keys_enabled} -eq 1 ]]; then
        get_priv_ssh_key
    fi
    # check SSH port usage
    check_port_usage ${ssh_host_port} "SSH host"
    # start simple webserver (in background)
    start_web_server
    # download boot/iso files
    download_boot_media
    download_guest_additions_media
    # create VM box with given settings
    create_box
    # host ip to connect from guest
    local host_ip=10.0.2.2
    # start VM
    if [[ ${gui_enabled} -eq 1 ]]; then
        VBoxManage startvm --type gui "${VM}"  && sleep ${boot_wait}
    else
        VBoxManage startvm --type headless "${VM}" && sleep ${boot_wait}
    fi
    # boot VM machine
    log_info "Sending keyboard scancodes:"
    local boot_cmd
    for boot_cmd in "${boot_cmd_sequence[@]}"; do
        if [[ -z "${boot_cmd}" ]]; then
            continue
        fi
        boot_cmd=${boot_cmd//%IP%/${host_ip}}
        boot_cmd=${boot_cmd//%PORT%/${kickstart_port}}
        boot_cmd=${boot_cmd//%NAME%/${VM}}
        log_info "${boot_cmd}"
        # converts string to scancode via external python script
        local boot_cmd_code=$(printf "${boot_cmd}" | convert_2_scancode.py)
        # sends code to VM
        local code
        for code in ${boot_cmd_code}; do
            if [[ "${code}" == "wait" ]]; then
                sleep 1
            else
                VBoxManage controlvm "${VM}" keyboardputscancode ${code}
                sleep 0.02
            fi
        done
        sleep ${boot_seq_wait}
    done

    # wait until machine will be ready (ssh connection start working) or timeout was reached
    kickstart_monitoring

    # stop webserver
    stop_web_server

    exit 0
}

create_box() {
    # Register vm
    VBoxManage createvm --name "${VM}" --ostype "${os_type_id}" --register
    _vm_creation_state=1

    # Creates disks
    # Get default location for disks
    local location=$(VBoxManage list systemproperties | grep "Default machine folder" | cut -d':' -f 2 | sed 's/^\s*//g')

    # SATA controller - place for hdd and iso files
    # SATA controller allow add 30 disks, but vbkick reserve port 0 for boot media and port 1 for guest additions
    # check disk_size lenght
    if [[ ${#disk_size[@]} -gt 28 ]]; then
        log_error "Too many disks in disk_size (limited to 28 disks)"
        return 1;
    fi
    if [[ "${_vb_version}" > "4.3.0" ]] || [[ "${_vb_version}" == "4.3.0" ]]; then
        VBoxManage storagectl "${VM}" --name "SATA Controller"\
        --add sata --hostiocache ${hostiocache} --portcount $((${#disk_size[@]}+2))
    else
        VBoxManage storagectl "${VM}" --name "SATA Controller"\
        --add sata --hostiocache ${hostiocache} --sataportcount $((${#disk_size[@]}+2))
    fi
    # SATA controller - add boot media
    VBoxManage storageattach "${VM}" --storagectl "SATA Controller"\
    --type "${boot_file_type}" --port 0 --device 0 --medium "${boot_file}"
    # SATA controller - create and add hdd disks
    local port_nr=2
    local disk
    for disk in "${disk_size[@]}"; do
        if [[ -z "${disk}" ]]; then
            continue
        fi
        VBoxManage createhd --filename "${location}/${VM}/${VM}-${port_nr}.${disk_format}"\
        --size ${disk} --format "${disk_format}" --variant Standard
        VBoxManage storageattach "${VM}" --storagectl "SATA Controller"\
        --port ${port_nr} --device 0 --type hdd --medium "${location}/${VM}/${VM}-${port_nr}.${disk_format}"
        local port_nr=$((port_nr+1))
    done
    # SATA controller - add VBoxGuestAdditions iso
    if [[ ${guest_additions_attach} -eq 1 ]]; then
        if [[ ! -z "${guest_additions_path}" ]]; then
            # custom VBoxGuestAdditions
            VBoxManage storageattach "${VM}" --storagectl "SATA Controller"\
            --type dvddrive --port 1 --device 0 --medium "${guest_additions_path}/VBoxGuestAdditions_${_vb_version}.iso"
        else
            # default VBoxGuestAdditions
            VBoxManage storageattach "${VM}" --storagectl "SATA Controller"\
            --type dvddrive --port 1 --device 0 --medium emptydrive
            VBoxManage storageattach "${VM}" --storagectl "SATA Controller"\
            --type dvddrive --port 1 --device 0 --medium additions
        fi
    fi

    # Tuning VM
    # setting cpu's
    VBoxManage modifyvm "${VM}" --cpus ${cpu_count}
    # setting memory size
    VBoxManage modifyvm "${VM}" --memory ${memory_size}
    # setting video memory size
    VBoxManage modifyvm "${VM}" --vram ${video_memory_size}
    # setting bootorder
    local bo_idx=1
    local bo
    for bo in "${boot_order[@]}"; do
        if [[ -z "${bo}" ]]; then
            VBoxManage modifyvm "${VM}" --boot${bo_idx} none
        else
            VBoxManage modifyvm "${VM}" --boot${bo_idx} ${bo}
        fi
        local bo_idx=$((bo_idx+1))
        if [[ ${bo_idx} -eq 5 ]]; then
            break
        fi
    done
    local i
    for ((i=${bo_idx}; i<=4; i++)); do
        VBoxManage modifyvm "${VM}" --boot${i} none
    done
    # setting networking
    VBoxManage modifyvm "${VM}" --nic1 nat --nictype1 ${nic_type} --cableconnected1 on
    # other settings
    local option
    for option in "${vm_options[@]}"; do
        if [[ -z "${option}" ]]; then
            continue
        fi
        local key="${option%%:*}"
        local value="${option##*:}"
        VBoxManage modifyvm "${VM}" --"${key}" "${value}"
    done
    # set extradata
    local extradata
    for extradata in "${vm_extradata[@]}"; do
        if [[ -z "${extradata}" ]]; then
            continue
        fi
        local key="${extradata%%:*}"
        local value="${extradata##*:}"
        VBoxManage setextradata "${VM}" "${key}" "${value}"
    done

    # ssh port NAT mapping; ssh port is a special one
    if ! is_port_present "${ssh_port_name}"; then
        VBoxManage controlvm "${VM}" natpf1 "${ssh_port_name},tcp,,${ssh_host_port},,${ssh_guest_port}"
    fi

    # extra ports NAT mapping
    add_extra_ports_mapping "${extra_ports[@]}"

    # add shared folders
    add_shared_folders "${shared_folders[@]}"
    _vm_creation_state=0
}

add_extra_ports_mapping() {
    local lc_extra_ports=("${@}")
    local port
    for port in "${lc_extra_ports[@]}"; do
        if [[ -z "${port}" ]]; then
            continue
        fi

        local IFS=':'
        local port_info=(${port})
        if [[ ${#port_info[@]} -ne 3 ]]; then
            log_error "one of the ports in extra_ports has invalid format."
            return 1
        fi
        local port_name="${port_info[0]}"
        local port_host="${port_info[1]}"
        local port_guest="${port_info[2]}"
        # add only if port doesn't exist
        if ! is_port_present "${port_name}"; then
            VBoxManage controlvm "${VM}" natpf1 "${port_name},tcp,,${port_host},,${port_guest}"
        fi
    done
}

remove_extra_ports_mapping() {
    local lc_extra_ports=("${@}")
    local port
    for port in "${lc_extra_ports[@]}"; do
        if [[ -z "${port}" ]]; then
            # note which extra ports were removed by moving _extraports_removed_ptr
            _extraports_removed_ptr=$((_extraports_removed_ptr+1))
            continue
        fi

        local IFS=':'
        local port_info=(${port})
        if [[ ${#port_info[@]} -ne 3 ]]; then
            log_error "one of the ports in extra_ports has invalid format."
            return 1
        fi
        local port_name="${port_info[0]}"
        if is_port_present "${port_name}"; then
            VBoxManage modifyvm "${VM}" --natpf1 delete "${port_name}"
            # note which extra ports were removed by moving _extraports_removed_ptr
            _extraports_removed_ptr=$((_extraports_removed_ptr+1))
        fi
    done
}

add_shared_folders() {
    local lc_shared_folders=("${@}")
    local folder
    for folder in "${lc_shared_folders[@]}"; do
        if [[ -z "${folder}" ]]; then
            continue
        fi

        local IFS=':'
        local folder_info=(${folder})
        if [[ ${#folder_info[@]} -lt 2 ]]; then
            log_error "one of the folders in shared_folders has no info about path."
            return 1
        fi
        local folder_name="${folder_info[0]}"
        local folder_path=$(prepare_path "${folder_info[1]}" 1)

        # check whether shared_folder already exist
        if is_shared_folder_present "${folder_name}"; then
            continue
        fi

        if [[ ${#folder_info[@]} -eq 2 ]]; then
            log_info "VBoxManage sharedfolder add  \"${VM}\" --name \"${folder_name}\" --hostpath \"${folder_path}\""
            VBoxManage sharedfolder add "${VM}" --name "${folder_name}" --hostpath "${folder_path}"
        elif [[ ${#folder_info[@]} -eq 3 ]]; then
            log_info "VBoxManage sharedfolder add  \"${VM}\" --name \"${folder_name}\" --hostpath \"${folder_path}\" --${folder_info[2]}"
            VBoxManage sharedfolder add "${VM}" --name "${folder_name}" --hostpath "${folder_path}" --"${folder_info[2]}"
        elif [[ ${#folder_info[@]} -eq 4 ]]; then
            log_info "VBoxManage sharedfolder add  \"${VM}\" --name \"${folder_name}\" --hostpath \"${folder_path}\" --${folder_info[2]} --${folder_info[3]}"
            VBoxManage sharedfolder add "${VM}" --name "${folder_name}" --hostpath "${folder_path}" --"${folder_info[2]}" --"${folder_info[3]}"
        else
            log_error "too much options in one of the shared_folders."
            return 1
        fi
    done
}

remove_shared_folders() {
    local lc_shared_folders=("${@}")
    local folder
    for folder in "${lc_shared_folders[@]}"; do
        if [[ -z "${folder}" ]]; then
            # note which shared folders were removed by moving _sharedfolders_removed_ptr
            _sharedfolders_removed_ptr=$((_sharedfolders_removed_ptr+1))
            continue
        fi

        local IFS=':'
        local folder_info=(${folder})
        if [[ ${#folder_info[@]} -lt 2 ]]; then
            log_error "one of the folders in shared_folders has no info about path."
            return 1
        fi
        if [[ ${#folder_info[@]} -gt 4 ]]; then
            log_error "too much options in one of the shared_folders."
            return 1
        fi
        local folder_name="${folder_info[0]}"
        if is_shared_folder_present "${folder_name}"; then
            VBoxManage sharedfolder remove "${VM}" --name "${folder_name}"
            # note which shared folders were removed by moving _sharedfolders_removed_ptr
            _sharedfolders_removed_ptr=$((_sharedfolders_removed_ptr+1))
        fi
    done
}

# Check whether machine was kickstarted before timeout
kickstart_monitoring() {
    local kickstart_counter=0
    local extra_ssh_options="-o ConnectionAttempts=1 -o ConnectTimeout=1"
    # ssh key authentication enabled
    if [[ ${ssh_keys_enabled} -eq 1 ]]; then
        # create path to ssh private key
        local key_path="${ssh_keys_path}/${ssh_priv_key}"
        printf "\n"
        log_info "Waiting for ssh login with user ${ssh_user} to 127.0.0.1:${ssh_host_port} to work, kickstart_timeout=${kickstart_timeout} sec"
        # wait until ssh start working (communication chanel with VM) or kickstart_timeout was reached
        while ! ssh "${ssh_user}@127.0.0.1" -q -t -i ${key_path} -p ${ssh_host_port} ${ssh_options} ${extra_ssh_options} -C "echo"\
            && [[ ${kickstart_counter} -le ${kickstart_timeout} ]]; do
            kickstart_counter=$((kickstart_counter+1))
            printf "."
            sleep 1
        done
        printf "\n"
    else
        # if no ssh key authentication enabled then wait until timeout will be reached
        log_info "Sleeping ${kickstart_timeout} seconds ..."
        sleep ${kickstart_timeout}
    fi
}

#@action
destroy_vm() {
    # check whether VM already exist
    if ! is_present; then
        log_error "'${VM}' doesn't exist"
        exit 1
    fi

    # destroy VM
    log_info "Destroy '${VM}'"
    local ans
    read -r -p "Are you sure? [y/N]" ans
    if [[ ! ${ans} =~ ^[Yy]$ ]]; then
        exit 1
    fi

    # check whether VM is alive
    if is_alive; then
        log_info "Poweroff '${VM}'"
        VBoxManage controlvm "${VM}" poweroff
        sleep 1
    fi

    log_info "Destroying '${VM}'..."
    VBoxManage unregistervm "${VM}" --delete
    exit 0
}

#@action
export_vm() {
    #
    # basic replacement for that vagrant command:
    # vagrant package --base "${VM}" --output "${VM}.box"
    # if more customisation required use: vagrant package (--help)
    #
    # tar command is required, check whether is installed
    depend_check "tar" "tar"
    # load vm description/definition
    local definition_fname="${1:-}"
    load_definition "${definition_fname}"
    # check whether VM_NAME.box exist in current dir
    if [[ -f "${VM}.box" ]]; then
        log_error "'${VM}.box' already exist in '$(pwd)'"
        exit 1
    fi
    # check whether VM exist
    if ! is_present; then
        log_error "'${VM}' doesn't exist"
        exit 1
    fi
    # check whether VM is running and shutdown it
    shutdown
    if ! is_powered_off; then
        log_error "'${VM}' is not powered off. Maybe has saved state."
        log_error "You may need to run: 'vbkick on \"${VM}\"' and 'vbkick shutdown \"${VM}\"'"
        log_error "To check '${VM}' state run: 'vbkick list | grep \"${VM}:\"'"
        exit 1
    fi

    # clearing previously set port forwarding rules (only if exist)
    if is_port_present "${ssh_port_name}"; then
        VBoxManage modifyvm "${VM}" --natpf1 delete "${ssh_port_name}"
        _ssh_natmapping_was_removed=1
    fi

    # rm extra ports (only if exist)
    remove_extra_ports_mapping "${extra_ports[@]}"

    # rm shared folder (only if exist)
    remove_shared_folders "${shared_folders[@]}"

    # create _tmp_dir for export data
    _tmp_dir=$(TMPDIR=. mktemp -d)
    # export VM to _tmp_dir
    VBoxManage export "${VM}" --output "${_tmp_dir}/box.ovf"
    # get VM MAC Address
    local mac_address=$(VBoxManage showvminfo --details --machinereadable "${VM}"\
    | grep macaddress1 | cut -d"=" -f 2)
    # add Vagrantfile
    printf "Vagrant.configure(\"2\") do |config|
    \t# This Vagrantfile is auto-generated by \`vbkick export\` to contain
    \t# the MAC address of the box. Custom configuration should be placed in
    \t# the actual \`Vagrantfile\` in this box.
    \tconfig.vm.base_mac = ${mac_address}
    end\n
    # Load include vagrant file if it exists after the auto-generated
    # so it can override any of the settings
    include_vagrantfile = File.expand_path(\"../include/_Vagrantfile\", __FILE__)
    load include_vagrantfile if File.exist?(include_vagrantfile)\n" > "${_tmp_dir}/Vagrantfile"
    # add metadata.json
    printf "{\"provider\":\"virtualbox\"}\n" > "${_tmp_dir}/metadata.json"
    # create VM_NAME.box (gzip) file
    cd ${_tmp_dir}
    tar -cvzf "${VM}.box" *
    cd ..
    mv "${_tmp_dir}/${VM}.box" .
    # remove _tmp_dir
    rm -rf ${_tmp_dir}
    # help recover some changes made on VM during exporting
    recover_vm_state
    log_info "Done: '$(pwd)/${VM}.box'"
    exit 0
}

recover_vm_state() {
    # destroy VM as creation process was unsuccessful
    if [[ ${_vm_creation_state} -eq 1 ]]; then
        log_info "Destroying not completed Virtual machine - '${VM}'"
        VBoxManage unregistervm "${VM}" --delete
        _vm_creation_state=0
    fi
    # add NAT mapping after exporting - only if exist prev.
    if [[ ${_ssh_natmapping_was_removed} -eq 1 ]]; then
        VBoxManage controlvm "${VM}" natpf1 "${ssh_port_name},tcp,,${ssh_host_port},,${ssh_guest_port}"
        _ssh_natmapping_was_removed=0
    fi
    # add extra ports after exporting - only if exist prev.
    if [[ ${_extraports_removed_ptr} -gt 0 ]]; then
        # add only folders which were removed, skip others (useful when SIGINT)
        local lc_extra_ports=("${extra_ports[@]:0:${_extraports_removed_ptr}}")
        add_extra_ports_mapping "${lc_extra_ports[@]}"
        _extraports_removed_ptr=0
    fi
    # add shared folder after exporting - only if exist prev.
    if [[ ${_sharedfolders_removed_ptr} -gt 0 ]]; then
        # add only folders which were removed, skip others (useful when SIGINT)
        local lc_shared_folders=("${shared_folders[@]:0:${_sharedfolders_removed_ptr}}")
        add_shared_folders "${lc_shared_folders[@]}"
        _sharedfolders_removed_ptr=0
    fi
}

#@action
turn_on() {
    # check whether VM exist
    if ! is_present; then
        log_error "'${VM}' doese not exist. Use 'vbkick build' to create the new VM."
        exit 1
    fi

    # check whether VM is already running
    if is_running; then
        # nothing to do
        log_ginfo "'${VM}' is already running..."
        exit 0
    elif is_paused; then
        VBoxManage controlvm "${VM}" resume
        log_info "'${VM}' was resumed."
        exit 0
    fi

    if [[ ${gui_enabled} -eq 1 ]]; then
        VBoxManage startvm --type gui "${VM}"
    else
        VBoxManage startvm --type headless "${VM}"
    fi
    exit 0
}

#@action
turn_off() {
    # check whether VM exist
    if ! is_present; then
        log_error "'${VM}' doese not exist. Use 'vbkick build' to create the new VM."
        exit 1
    fi

    # check whether VM is alive
    if ! is_alive; then
        log_ginfo "'${VM}' is already turn off."
        exit 0
    fi

    # load vm description/definition
    local definition_fname="${1:-}"
    load_definition "${definition_fname}"

    #exec shutdown
    shutdown
    exit 0
}

shutdown() {
    # check whether VM is running and exec shutdown_cmd via SSH
    if [[ -n "${shutdown_cmd}" ]]; then
        if is_running; then
            log_info "Shutting down '${VM}'."
            ssh_do_launch "${shutdown_cmd}" || true
            # wait until VM is down or shutdown_timeout was reached
            local shutdown_counter=0
            while is_running && [[ ${shutdown_counter} -le ${shutdown_timeout} ]]; do
                shutdown_counter=$((shutdown_counter+1))
                printf "."
                sleep 1
            done
            printf "\n"
            sleep 3
        fi
    fi

    # check whether VM is still running, if so use acpipowerbutton
    if is_running; then
        VBoxManage controlvm "${VM}" acpipowerbutton
        log_info "'${VM}' - acpipowerbutton was used. Waiting ${shutdown_timeout} seconds..."
        sleep ${shutdown_timeout}
    fi

    # check whether VM is still alive (e.g. paused), if so poweroff it using hard way.
    if is_alive; then
        VBoxManage controlvm "${VM}" poweroff
        log_info "'${VM}' was powered off."
        sleep 3
    fi
    if is_powered_off; then
        log_info "'${VM}' was shutdown cleanly."
    else
        log_warning "'${VM}' has different than 'powered off' state."
    fi
}

update_guest_additions_media() {
    # check whether VM exist
    if ! is_present; then
        log_error "'${VM}' doesn't exist. Use \"vbkick build\" to create the new VM."
        return 1
    fi
    # get current guest version
    if VBoxManage guestproperty enumerate "${VM}" | grep -q "GuestAdd/Version"; then
        # guest already exist, get current version
        local guest_version=$(VBoxManage guestproperty get "${VM}" "/VirtualBox/GuestAdd/Version" | cut -f 2 -d " ")
    else
        # guest doesn't exist
        local guest_version=""
    fi

    # check whether we need update or install VBoxGuestAdditions
    if [[ "${_vb_version}" == "${guest_version}" ]]; then
        log_ginfo "VBoxGuestAdditions on '${VM}' is up-to-date - update media iso is not needed."
        return
    fi
    # TODO [LOW]: use Storage Controller Name (1) and type to find controller name
    # check whether "SATA Controller (1, 0)" exist - require to attach iso and creates /dev/sr1 or /dev/sr0
    if ! VBoxManage showvminfo "${VM}" | grep -qw "SATA Controller (1, 0)"; then
        log_error "'SATA Controller (1, 0)' for '${VM}' doesn't exist."
        log_error "'SATA Controller' is sata controller name used by vbkick."
        log_error "More: 'VBoxManage showvminfo \"${VM}\" | grep -w \"Controller\"'\n"
        log_error "To create proper controller use:"
        log_error "'VBoxManage storagectl \"${VM}\" --name \"SATA Controller\" --add sata --hostiocache ${hostiocache} --portcount $((${#disk_size[@]}+2))'"
        log_error "'VBoxManage storageattach \"${VM}\" --storagectl \"SATA Controller\" --type dvddrive --port 1 --device 0 --medium emptydrive'\n"
        log_error "To do this '${VM}' must be shutdown !!!"
        log_error "Remember - VM Guest may have only one sata controller."
        return 1
    fi
    # Attach new VBoxGuestAdditions to install
    # vbkick creates VM with SATA Controller port 1 available for VBoxGuestAdditions iso.
    if [[ ! -z "${guest_additions_path}" ]]; then
        # custom VBoxGuestAdditions
        download_guest_additions_media
        VBoxManage storageattach "${VM}" --storagectl "SATA Controller"\
        --type dvddrive --port 1 --device 0 --medium "${guest_additions_path}/VBoxGuestAdditions_${_vb_version}.iso" --forceunmount
    else
        # default VBoxGuestAdditions
        VBoxManage storageattach "${VM}" --storagectl "SATA Controller"\
        --type dvddrive --port 1 --device 0 --medium additions --forceunmount
    fi
    # Note: Guest OS (Linux) does not support automatic Guest Additions updating:
    # VBoxManage guestcontrol <vmname>|<uuid> updateadditions
    # Manuall Guest Additions update/installation is required (via lazy_update cmd).
}

#@action
validate_vm() {
    #
    # test should be smart enough to check what I really want to test
    # e.g. If I don't need chef, don't test whether I have chef
    #
    # load vm description/definition
    local definition_fname="${1:-}"
    load_definition "${definition_fname}"
    # exec scripts on VM Guest via ssh
    ssh_exec ${#validate_transport[@]} "${validate_transport[@]}" "${validate_launch[@]}"
    exit 0
}

#@action
lazy_postinstall() {
    # load vm description/definition
    local definition_fname="${1:-}"
    load_definition "${definition_fname}"
    # exec scripts on VM Guest via ssh
    ssh_exec ${#postinstall_transport[@]} "${postinstall_transport[@]}" "${postinstall_launch[@]}"
    exit 0
}

#@action
lazy_update() {
    # load vm description/definition
    local definition_fname="${1:-}"
    load_definition "${definition_fname}"
    # Check whether VBoxGuestAdditions should be installed. If not then not update additions.
    if [[ ${guest_additions_attach} -eq 1 ]]; then
        update_guest_additions_media
    fi
    # Run other update scripts on VM Guest via ssh
    ssh_exec ${#update_transport[@]} "${update_transport[@]}" "${update_launch[@]}"
    exit 0
}

ssh_exec() {
    #
    # transport scripts to VM Guest via SCP and exec them via SSH
    #
    # get number of transport files/directories; transport array length
    local pos=${1}
    shift
    # get transport array; everything to $pos
    local transport=("${@:1:${pos}}")
    shift ${pos}
    # get launch array;
    local launch=("${@}")

    # check whether VM exist
    if ! is_present; then
        log_error "'${VM}' doesn't exist"
        return 1
    fi
    # check whether VM is running
    if ! is_running; then
        log_error "'${VM}' is not running..."
        return 1
    fi

    # checking port forwarding (if no proper rules, try add new one for NAT mapping)
    if ! VBoxManage showvminfo "${VM}" | grep "NIC 1" | grep "host port = ${ssh_host_port}"\
        | grep -q "guest port = ${ssh_guest_port}"; then
        log_info "NAT mapping - enable ssh port forwarding"
        VBoxManage controlvm "${VM}" natpf1 "${ssh_port_name},tcp,,${ssh_host_port},,${ssh_guest_port}"
    fi

    # ssh key authentication enabled
    if [[ ${ssh_keys_enabled} -eq 1 ]]; then
        # if key not exist then get it
        get_priv_ssh_key
    fi

    # check whether all pkt can by transported, before starting transporting -
    # - be a bit more atomic
    local pkt
    for pkt in "${transport[@]}"; do
        if [[ -z "${pkt}" ]] || [[ -d "${pkt}" ]] || [[ -f "${pkt}" ]]; then
            continue
        else
            # pkt is neither file nor directory
            log_error "${pkt} is neither file nor directory"
            return 1
        fi
    done

    # complex function shouldn't be check by 'if'; it has big consequence how function definition is processed
    # whole body of function will be executed even error occur (e.g. one of the subfunctions exit with error code 1)
    # I'm aware of this and here it's fine to check ssh_do_transport
    if ! ssh_do_transport "${transport[@]}"; then
        ssh_do_cleanup "${transport[@]}"
        return 1
    fi
    ssh_do_launch "${launch[@]}"
    ssh_do_cleanup "${transport[@]}"
}

ssh_do_transport() {
    local transport=("${@}")
    local pkt
    # transport scripts to guest
    for pkt in "${transport[@]}"; do
        if [[ -z "${pkt}" ]]; then
            continue
        fi
        log_info "Scp: ${pkt}"
        # check whether pkt is file or dir
        if [[ -d "${pkt}" ]]; then
            # pkt is directory
            if [[ ${ssh_keys_enabled} -eq 1 ]]; then
                # create path to ssh private key
                local key_path="${ssh_keys_path}/${ssh_priv_key}"
                scp -q -P ${ssh_host_port} -i "${key_path}" ${ssh_options} -r "${pkt}" "${ssh_user}@127.0.0.1:~${ssh_user}"
            else
                # 1 mean scp directory (recursive)
                auto_passwd_scp "${pkt}" 1
            fi
        elif [[ -f "${pkt}" ]]; then
            # pkt is file
            if [[ ${ssh_keys_enabled} -eq 1 ]]; then
                # create path to ssh private key
                local key_path="${ssh_keys_path}/${ssh_priv_key}"
                scp -q -P ${ssh_host_port} -i "${key_path}" ${ssh_options} "${pkt}" "${ssh_user}@127.0.0.1:~${ssh_user}"
            else
                # 0 mean scp file
                auto_passwd_scp "${pkt}" 0
            fi
        fi
        sleep 1
    done
}

ssh_do_launch() {
    local launch=("${@}")
    local cmd
    # run commands via ssh
    for cmd in "${launch[@]}"; do
        if [[ -z "${cmd}" ]]; then
            continue
        fi
        # %HOST% tag - check whether command should be executed on host (not guest)
        if [[ "${cmd}" =~ ^\ *%HOST% ]]; then
            # extract command
            cmd=${cmd//%HOST%/}
            # process defined/template variables
            cmd=$(prepare_path "${cmd}" 0)
            log_info "Exec (on host): ${cmd}"
            eval "${cmd}"
            continue
        fi
        log_info "Exec: ${cmd}"
        if [[ ${ssh_keys_enabled} -eq 1 ]]; then
            # create path to ssh private key
            local key_path="${ssh_keys_path}/${ssh_priv_key}"
            ssh -q "${ssh_user}@127.0.0.1" -t -i ${key_path} -p ${ssh_host_port} ${ssh_options} -C "${cmd}"
        else
            auto_passwd_ssh "${cmd}"
        fi
        sleep 1
    done
}

ssh_do_cleanup() {
    local transport=("${@}")
    if [[ ${clean_transported} -eq 0 ]]; then
        return
    fi
    local pkt
    # clean after scp by rm transported media/scripts
    for pkt in "${transport[@]}"; do
        if [[ -z "${pkt}" ]]; then
            continue
        fi
        log_info "Clean transported: ${pkt}"
        local pkt_to_clean=$(basename "${pkt}")
        if [[ ${ssh_keys_enabled} -eq 1 ]]; then
            # create path to ssh private key
            local key_path="${ssh_keys_path}/${ssh_priv_key}"
            ssh -q "${ssh_user}@127.0.0.1" -t -i ${key_path} -p ${ssh_host_port} ${ssh_options} -C "cd ~${ssh_user} && rm -rf ${pkt_to_clean}"
        else
            auto_passwd_ssh "cd ~${ssh_user} && rm -rf ${pkt_to_clean}"
        fi
        sleep 1
    done
}

#@action
lazy_ssh() {
    # check whether VM exist
    if ! is_present; then
        log_error "'${VM}' doesn't exist"
        exit 1
    fi
    # check whether VM is running
    if ! is_running; then
        log_error "'${VM}' is not running..."
        exit 1
    fi
    # load vm description/definition
    local definition_fname="${1:-}"
    load_definition "${definition_fname}"
    if [[ ${ssh_keys_enabled} -eq 1 ]]; then
        # if key not exist then get it
        get_priv_ssh_key
        # create path to ssh private key
        local key_path="${ssh_keys_path}/${ssh_priv_key}"
        ssh -q "${ssh_user}@127.0.0.1" -t -i ${key_path} -p ${ssh_host_port} ${ssh_options}
    else
        auto_passwd_ssh ""
    fi
    exit 0
}

auto_passwd_ssh() {
    local cmd="${1}"
    if command -v expect >/dev/null 2>&1; then
        if [[ -z "${cmd}" ]]; then
            # No cmd to exec, interactive shell
            local expect_cmd="ssh -q \"${ssh_user}@127.0.0.1\" -t -p ${ssh_host_port} ${ssh_options}"
        else
            local expect_cmd="ssh -q \"${ssh_user}@127.0.0.1\" -t -p ${ssh_host_port} ${ssh_options} -C \"${cmd}\""
        fi
        expect -c "log_user 0; spawn ${expect_cmd}; expect password; send \"${ssh_password}\r\"; interact; catch wait reason; exit [lindex \$reason 3]"
    else
        log_warning "'expect' command not exist - install 'expect (tcl)' to automate ssh authentication without ssh_key."
        log_warning "To use ssh_key authentication setup ssh_keys_enabled=1 in your definition file."
        # Process without expect
        if [[ -z "${cmd}" ]]; then
            # No cmd to exec, interactive shell
            ssh -q "${ssh_user}@127.0.0.1" -t -p ${ssh_host_port} ${ssh_options}
        else
            ssh -q "${ssh_user}@127.0.0.1" -t -p ${ssh_host_port} ${ssh_options} -C "${cmd}"
        fi
    fi
}

auto_passwd_scp() {
    local src="${1}"
    local recursive="${2}"
    if command -v expect >/dev/null 2>&1; then
        if [[ ${recursive} -eq 1 ]]; then
            local expect_cmd="scp -q -P ${ssh_host_port} ${ssh_options} -r \"${src}\" \"${ssh_user}@127.0.0.1:~${ssh_user}\""
        else
            local expect_cmd="scp -q -P ${ssh_host_port} ${ssh_options} \"${src}\" \"${ssh_user}@127.0.0.1:~${ssh_user}\""
        fi
        expect -c "log_user 0; spawn ${expect_cmd}; expect password; send \"${ssh_password}\r\"; expect eof; catch wait reason; exit [lindex \$reason 3]"
    else
        log_warning "'expect' command not exist - install 'expect (tcl)' to automate ssh authentication without ssh_key."
        log_warning "To use ssh_key authentication setup ssh_keys_enabled=1 in your definition file."
        # Process without expect
        if [[ ${recursive} -eq 1 ]]; then
            scp -q -P ${ssh_host_port} ${ssh_options} -r "${src}" "${ssh_user}@127.0.0.1:~${ssh_user}"
        else
            scp -q -P ${ssh_host_port} ${ssh_options} "${src}" "${ssh_user}@127.0.0.1:~${ssh_user}"
        fi
    fi
}

#@action
make_clone(){
    # check whether VM exist
    if ! is_present; then
        log_error "'${VM}' doesn't exist"
        exit 1
    fi

    if is_alive; then
        log_error "'${VM}' is alive. VM must be shut down to create clone."
        exit 1
    fi

    # check whether clone_name is provided and take the snapshot with this name
    if [[ -n "${1:-}" ]]; then
        local clone_name="${1:-}"
        if is_present "${clone_name}"; then
            log_error "'${clone_name}' already exists."
            exit 1
        fi
    # clone_name is not provided, make the clone with auto generate name - {VM}-clone{NR++}
    elif is_present "\"${VM}-clone[0-9]\+\""; then
        # clone are numered, e.g.: vm_name:aa22-snap-aa11 -> clone_name:aa22-snap-aa11-snap1..999..
        # get all clones match our clone pattern, extract NR value from each clonename, get the highes NR
        local last_clone_nr=$(VBoxManage list vms | cut -f 1 -d'{' | grep "\"${VM}-clone[0-9]\+\""\
            | sed "s/${VM}-clone//;s/\"//g" | sort -gu | tail -1)
        last_clone_nr=$((last_clone_nr+1))
        local clone_name="${VM}-clone${last_clone_nr}"
    # clone with the auto generate name doesn't exist, make the first one.
    else
        local clone_name="${VM}-clone1"
    fi
    VBoxManage clonevm "${VM}" --name "${clone_name}" --register
    log_info "'${VM}' has been cloned as '${clone_name}'."
    exit 0
}

#@action
take_snapshot(){
    # check whether VM exist
    if ! is_present; then
        log_error "'${VM}' doesn't exist"
        exit 1
    fi

    # check whether snap_name is provided and take the snapshot with this name
    if [[ -n "${1:-}" ]]; then
        # Note: VBox allow make multiple snapshots with the same name, they are identify by UUID
        local snap_name="${1:-}"
    # snap_name is not provided, take the snapshot with auto generate name - {VM}-snap{NR++}
    elif is_snapshot_present "\"${VM}-snap[0-9]\+\""; then
        # it would be nice to use `date` but it isn't portable between linux/osx/freebsd
        # so that snapshot are numered, e.g.:
        # vm_name:aa22-snap-aa11 -> snap_name:aa22-snap-aa11-snap1..999..
        # get all snapshots match our snap pattern, extract NR value from each snapname, get the highes NR
        local last_snap_nr=$(VBoxManage snapshot "${VM}" list --machinereadable | grep ^SnapshotName\
            | cut -d"=" -f 2- | grep "\"${VM}-snap[0-9]\+\"" | sed "s/${VM}-snap//;s/\"//g" | sort -gu | tail -1)
        last_snap_nr=$((last_snap_nr+1))
        local snap_name="${VM}-snap${last_snap_nr}"
    # snapshot with the auto generate name doesn't exist, make the first one.
    else
        local snap_name="${VM}-snap1"
    fi
    VBoxManage snapshot "${VM}" take "${snap_name}" --live
    log_info "'${snap_name}' snapshot was taken."
    exit 0
}

#@action
restore_snapshot(){
    # check whether VM exist
    if ! is_present; then
        log_error "'${VM}' doesn't exist"
        exit 1
    fi

    if ! has_snapshots; then
        log_error "No snapshots found for the '${VM}'"
        exit 1
    fi

    if is_alive; then
        log_error "'${VM}' is alive. VM must be shut down to restore snapshot."
        exit 1
    fi

    local snap_name="${1:-}"
    # check whether snap_name is provided and delete the requested snap_name
    if [[ -n "${snap_name}" ]]; then
        if ! is_snapshot_present "\"${snap_name}\""; then
            log_error "'${snap_name}' snapshot doesn't exist for the '${VM}'"
            log_error "Use 'vbkick lssnap \"${VM}\"' to list all available snapshots."
            exit 1
        fi
        VBoxManage snapshot "${VM}" restore "${snap_name}"
        log_info "'${snap_name}' snapshot was restored."
        exit 0
    fi
    VBoxManage snapshot "${VM}" restorecurrent
    log_info "Current snapshot was restored."
    exit 0
}

#@action
delete_snapshot(){
    # check whether VM exist
    if ! is_present; then
        log_error "'${VM}' doesn't exist"
        exit 1
    fi

    if ! has_snapshots; then
        log_error "No snapshots found for the '${VM}'"
        exit 1
    fi
    local snap_name="${1:-}"
    # check whether snap_name is provided and delete the requested snap_name
    if [[ -n "${snap_name}" ]]; then
        if ! is_snapshot_present "\"${snap_name}\""; then
            log_error "'${snap_name}' snapshot doesn't exist for the '${VM}'"
            log_error "Use 'vbkick lssnap \"${VM}\"' to list all available snapshots."
            exit 1
        fi
    # snap_name is not provided, remove the current snapshot
    else
        snap_name=$(VBoxManage snapshot "${VM}" list --machinereadable | grep ^CurrentSnapshotUUID\
            | cut -d"=" -f 2- | sed 's/"//g')
    fi
    VBoxManage snapshot "${VM}" delete "${snap_name}"
    log_info "'${snap_name}' snapshot was deleted."
    exit 0
}

#@action
list_snapshots(){
    # check whether VM exist
    if ! is_present; then
        log_error "'${VM}' doesn't exist"
        exit 1
    fi

    if ! has_snapshots; then
        log_error "No snapshots found for the '${VM}'"
        exit 1
    fi
    VBoxManage snapshot "${VM}" list
    exit 0
}

start_web_server() {
    # Do not start webserver - remote server is used instead to serve kickstart files.
    if [[ ${webserver_disabled} -eq 1 ]]; then
        return
    fi
    # check whether port is not used by other proc
    check_port_usage ${kickstart_port} "kickstart"
    # start simple webserver serving files in background
    local py_version=$(python -V 2>&1 | cut -d' ' -f 2 | cut -d'.' -f 1)
    if [[ ${py_version} -eq 2 ]]; then
        _webserver_module="SimpleHTTPServer"
    elif [[ ${py_version} -eq 3 ]]; then
        _webserver_module="http.server"
    else
        log_error "Unknown python version."
        return 1
    fi
    python -m ${_webserver_module} ${kickstart_port} &
    # get the pid already spawned process, to kill it later
    _web_pid=$!
    # update _webserver_state variable
    _webserver_state=1
    sleep 2
    # check whether web server was really started
    if ! is_port_used ${kickstart_port}; then
        log_error "webserver was not started"
        if kill -s 0 ${_web_pid} 2>/dev/null; then
            kill ${_web_pid}
        fi
        _webserver_state=0
        return 1
    fi
    log_info "webserver has been started (pid ${_web_pid})"
}

stop_web_server() {
    # check whether webserver is running
    if [[ ${_webserver_state} -eq 0 ]]; then
        return
    fi
    log_info "Stopping webserver (pid ${_web_pid})"
    # with "set -e -E" if kill command fail then ERR trap is processing
    # simply execution of function is not continued
    _webserver_kill_cmd_state=1
    # check whether process exist and accept signals before sending SIGTERM
    if kill -s 0 ${_web_pid} 2>/dev/null; then
        kill ${_web_pid}
    fi
    _webserver_kill_cmd_state=0
    # update _webserver_state variable
    _webserver_state=0
    # kill command is sucessfull when SIGTERM is sent to running process
    # not when child process was really killed
    if ! ps -ef | grep "python -m ${_webserver_module} ${kickstart_port}" | grep -qv grep; then
        log_info "webserver was stopped"
    else
        log_warning "problem with stopping webserver. Kill process manually"
        ps -ef | grep "python -m ${_webserver_module} ${kickstart_port}" | grep -v grep
    fi
}

# (signals and error handler) - cleaning after ctr-c, etc.
clean_up() {
    log_info "Signal/Error handler - cleanup before exiting..."
    exit 1
}

on_exit(){
    # this is a finally block - exec always on exit
    if [[ ${_webserver_kill_cmd_state} -eq 0 ]]; then
        # stop webserver (only if stop_web_server function didn't fail previuosly)
        stop_web_server
    else
        # previuosly executed stop_web_server function fail in killing $_web_pid
        log_warning "problem with killing webserver (proc ${_web_pid}). Kill process manually."
    fi
    # clean _tmp_dir if exist
    if [[ -d ${_tmp_dir} ]]; then
        rm -rf ${_tmp_dir}
    fi
    # help recover some changes made on VM during exporting
    recover_vm_state
}

main() {
    local args_num=$#
    if [[ ${args_num} -eq 1 ]]; then
        # check whether we have everything to start with vbkick
        dependencies_check
        process_1_args "${1}"
    elif [[ ${args_num} -eq 2 ]] || [[ ${args_num} -eq 3 ]]; then
        # check whether we have everything to start with vbkick
        dependencies_check
        _vb_version=$(get_vb_version)
        process_2_args "${1}" "${2}" "${3:-}"
    else
        # wrong number of arguments
        usage
        exit 1
    fi
}

## MAIN ##
# signals and errors handler
# Note: no exit handler is set, so 'exit 1' ends the program without running clean_up,
# this is done on purpose to not run clean_up twice when error occur
trap clean_up SIGHUP SIGINT SIGTERM ERR
trap on_exit EXIT
main "${@}"
