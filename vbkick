#!/bin/bash

# The MIT License
#
# Copyright (c) 2013, Kamil Wilas (wilas.pl)
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

# Help build Virtualbox guest VMs and Vagrant base boxes

# Secure bash
# More about options: http://wiki.bash-hackers.org/commands/builtin/set
# treat unset variables as an error
# (it also complain if you forget about required options in definition.cfg)
set -u;
# exit when cmd fail (use ERR trap for clean exit)
set -e; set -E;
# fail the entire pipeline if any part of it fails
set -o pipefail;
# debug mode
#set -x;
# http://mywiki.wooledge.org/glob
shopt -s failglob;
# enable POSIX mode
# http://www.gnu.org/software/bash/manual/html_node/Bash-POSIX-Mode.html
set -o posix    

# VM default settings - basic
hostiocache="on"
cpu_count=1
memory_size=512
disk_size=(10140)
disk_format="vdi"
video_memory_size=10
# list of VM options: ("option1:value" "option2:value")
vm_options=("ioapic:on")
# by default gui enabled
gui_enabled=1
# by default add shared folder - to disable: shared_folder=""
shared_folder="vbkick"

# Guest Additions default settings
# set to 0 to not attach VBoxGuestAdditions iso to guest
guest_additions_attach=1
# path where guest_additions should be download, if empty then not download custom VBoxGuestAdditions to host, use default one
guest_additions_path=""

# Boot default settings
#boot_file -> required option, fail if not in definition
#boot_file_src -> required option, fail if not in definition
# type of boot media e.g.: hdd, dvddrive; by default dvddrive
boot_file_type="dvddrive"
# default path for src media needed to create destination boot_file
boot_file_src_path="iso"
# by default sha256sum is empty
# WARNING is given during processing if sha256 sum is wrong (use: sha256sum --help)
boot_file_src_sha256=""
# by default unpacke is not needed
boot_file_unpack_cmd=""
# where is the path and the filename after unpack
boot_file_unpack_name=""
# is boot_file_src raw image and need to be converted
boot_file_convert_from_raw=0
# whether use cp or mv when boot_file is created form boot_file_src_file; 
# mv mean don't keep boot_file_src_file; keep only boot_file; by default 0 - use mv
keep_boot_src_file=0
# default time before boot_cmd_sequence start
boot_wait=10
# list of boot_cmd: ("cmd1" "cmd2" "cmd3")
boot_cmd_sequence=("")
# default number of second wait between each boot_cmd
boot_seq_wait=1
# default webserver port to serve kickstart files
kickstart_port=7122
# default max webserver live time
kickstart_timeout=7200
#TODO [LOW]: update_boot_media=1 replace boot (usb, iso) media during update action, usefull for smartOS, host must be shutdown

# SSH default settings (veeded to run vbkick validate and/or lazy_posinstall)
# by default use ssh keys
ssh_keys_enabled=1
# default user
ssh_user="vbkick"
# default user password - not use when ssh_keys authentication is enabled
ssh_password="vbkick"
# default path to ssh keys
ssh_keys_path="keys"
# default private key name
ssh_priv_key="vbkick_key"
# default auto-download path 
ssh_priv_key_src="https://raw.github.com/wilas/vbkick/master/keys/vbkick_key"
# default ssh host port
ssh_host_port=2222
# default (22) ssh guest port to forwarding
ssh_guest_port=22
# default extra ssh and scp options
# UserKnownHostsFile - database file to use for storing the user host keys
# StrictHostKeyChecking - if "no" then automatically add new host keys to the host key database file
# you may consider editing ssh config: http://superuser.com/questions/141344/ssh-dont-add-hostkey-to-known-hosts
ssh_options="-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o NumberOfPasswordPrompts=1"

# Lazy Postinstall default settings
# list of files and directories to transport to guest
postinstall_transport=("")
# list of postinstall commands
postinstall_launch=("")

# Validate default settings
# list of files and directories to transport to guest
validate_transport=("")
# list of validate commands
validate_launch=("")

# Lazy Update default settings
# list of files and directories to transport to guest
update_transport=("")
# list of update commands
update_launch=("")

# Clean
# list of files to autoupdate VBOX_VERSION value
files_to_autoupdate_vbox_version=("")
# rm or not already transported via SCP files/directories (from postinstall, validate)
clean_transported=0
# nice for OS shutdown command
shutdown_cmd="sudo /sbin/halt -h -p"
# when timeout is reached and VM is still running, hard poweroff is used
shutdown_timeout=20

# Other global variables - do not use it in definition.cfg (will be overwrite during program runtime)
# virtual machine name
VM=""
# 0 - webserver is not running or kill isn't able to stop it
webserver_status=0
# 0 - webserver was killed cleanly or we didn't try kill it yet
webserver_kill_status=0
# during exporting tmp directory is created
tmp_dir=""
# during exporting NAT mapping is removed (temporary) - help recover state before exporting
natmapping_was_removed=0
# during exporting Shared folder is removed (temporary) - help recover state before exporting
sharedfolder_was_removed=0

# For nice printing
GREEN="\e[1;32m"
RED="\e[1;31m"
YELLOW="\e[1;33m"
NORMAL="\e[0m"
function green {
    printf "$GREEN$*$NORMAL"
}
function red {
    printf "$RED$*$NORMAL"
}
function yellow {
    printf "$YELLOW$*$NORMAL"
}

# Display help
function usage {
    printf "Desc: the automatic Virtualbox Guests and Vagrant Base Boxes builder\n"
    printf "\n"
    printf "Usage: vbkick ACTION VM_NAME\n"
    printf "\n"
    printf "Available actions:\n"
    printf "\tbuild                 build VM\n"
    printf "\tpostinstall           run postinstall scripts via ssh\n"
    printf "\tvalidate              run validate/feature scripts via ssh\n"
    printf "\texport                export VM and creates Vagrant VM_NAME.box\n"
    printf "\tupdate                run update scripts via ssh\n"
    printf "\tdestroy               destroy VM\n"
    printf "\tssh                   ssh to VM\n"
    printf "\ton                    turn on VM\n"
    printf "\tshutdown              shutdown VM\n"
    printf "\thelp                  display this help and exit\n"
    printf "\n"
}

# Cmd line parser, take 2 args
function process_args {
    VM="${2}"
    case "$1" in
        "build") build_vm ;;
        "destroy") destroy_vm ;;
        "export") export_vm ;;
        "validate") validate_vm ;;
        "postinstall") lazy_postinstall ;;
        "update") lazy_update ;;
        "ssh") lazy_ssh ;;
        "on") turn_on ;;
        "shutdown") turn_off ;;
        *) usage; exit ;;
    esac
}

# Help automatically update/maintain value of VBOX_VERSION in given files list
function autoupdate_files_with_vbox_version {
    for file in "${files_to_autoupdate_vbox_version[@]}"; do
        # check whether file exist
        if [ -s "${file}" ]; then
            # example value to update: VBOX_VERSION="4.2.12", but ignore comments
            sed -r -i "/^#/!s/(VBOX_VERSION)=\"([0-9\.]+)\"/\1=\"$vb_version\"/g" "${file}"
        fi
    done
}

# Load definition.cfg config file; it overwrite default settings
function load_definition {
    if [ -s "definition.cfg" ]; then
        # In POSIX mode the '.' and 'source' builtins do not search the current directory
        # for the filename argument if it is not found by searching PATH.
        . "./definition.cfg"
    else 
        printf "Not existing or empty definition.cfg file in `pwd`\n"
        printf "Terminating...\n" >&2
        exit 1
    fi
    autoupdate_files_with_vbox_version
}

# Get virtualbox version
function get_vb_version {
    local version=$(VBoxManage --version) # e.g. 4.2.12r84980
    local version=${version%r*} #e.g. 4.2.12
    printf "${version}"
}

# Check whether given directory exist
function prepare_path {
    local path="${1}"
    local mkdir_path="${2}"
    # Process special variables in path definition e.g. path="%VBOXFOLDER%/%NAME%"
    local location=$(VBoxManage list  systemproperties | grep "Default machine folder" | cut -d':' -f 2 | sed 's/^ *//g')
    local path=${path//%SRCPATH%/${boot_file_src_path}}
    local path=${path//%VBOXFOLDER%/${location}}
    local path=${path//%PWD%/`pwd`}
    local path=${path//%HOME%/~}
    local path=${path//%NAME%/${VM}}
    # Creates dir if necessary
    if [ $mkdir_path -eq 1 ] && [ ! -z "${path}" ] && [ ! -d "${path}" ]; then
        mkdir -p "${path}"
    fi
    # Return path
    printf "${path}"
}

# Downloads custom VBoxGuestAdditions if required
function download_guest_additions_media {
    if [ -z "${guest_additions_path}" ]; then
        # nothing to do
        return
    fi
    guest_additions_path=$(prepare_path "${guest_additions_path}" 1)
    # check whether VBoxGuestAdditions exist
    if [ ! -f "${guest_additions_path}/VBoxGuestAdditions_${vb_version}.iso" ]; then
        local additions_url="http://download.virtualbox.org/virtualbox/${vb_version}/VBoxGuestAdditions_${vb_version}.iso"
        curl -o "${guest_additions_path}/VBoxGuestAdditions_${vb_version}.iso" "${additions_url}"
    fi
    # rm useless images
    remove_guest_additions_media
}

# Remove other (not needed) VBoxGuestAdditions from media directory
function remove_guest_additions_media {
    if [ -z "${guest_additions_path}" ]; then
        # nothing to do
        return
    fi
    guest_additions_path=$(prepare_path "${guest_additions_path}" 0)
    # true is use to not fail whole cmd, and return empty string 
    local file_list=$(ls "${guest_additions_path}" | grep "GuestAdditions" | grep -v "${vb_version}" || true)
    # continue only if we have some files to remove
    if [ -n "${file_list}" ]; then
        printf "List of VBoxGuestAdditions files to remove:\n"
        for file in ${file_list}; do
            printf "${file}\n"
        done
        # to remove files ask about confirmation
        read -r -p "Do you want remove above VBoxGuestAdditions files? [y/N]" ans
        if [[ $ans =~ ^[Yy]$ ]]; then
            for file in ${file_list}; do
                printf "${file}\n"
                rm -f "${guest_additions_path}/${file}"
            done
        fi
    fi
}

# Prepare installation/boot media
function download_boot_media {
    local boot_file_path=$(dirname "${boot_file}")
    local boot_file_name=$(basename "${boot_file}")
    local boot_file_path=$(prepare_path "${boot_file_path}" 1)
    boot_file="${boot_file_path}/${boot_file_name}"
     
    # check whether boot file exist
    if [ -f "${boot_file}" ]; then
        # file exist, nothing to do
        return
    fi

    # boot_file_src is empty (not defined)
    if [ -z "${boot_file_src}" ]; then 
        red "${boot_file} not exist and boot_file_src is empty\n"
        exit 1
    fi

    # the temporary name for boot_file is last part from boot_file_src
    local tmp_name=$(basename "${boot_file_src}")
    boot_file_src_path=$(prepare_path "${boot_file_src_path}" 1)
    local boot_file_src_file="${boot_file_src_path}/${tmp_name}"
    # check whether boot_file_src exist
    if [ ! -f "${boot_file_src_file}" ]; then
        curl "${boot_file_src}" -o "${boot_file_src_file}"
    fi

    # verify boot_file_src sha256sum
    local get_sha256=$(sha256sum "${boot_file_src_file}" | cut -d" " -f 1)
    if [[ "${boot_file_src_sha256}" != "${get_sha256}" ]]; then
        yellow "WARNING: SHA256SUM is different then expected !\n"
        read -r -p "Do you want continue? [y/N]" ans
        if [[ ! $ans =~ ^[Yy]$ ]]; then
            exit 1
        fi
    else
        printf "INFO: SHA256SUM:${boot_file_src_sha256} is valid.\n"
    fi

    # process unpack
    if [ ! -z "${boot_file_unpack_cmd}" ]; then
        # check whether boot_file_unpack_name is empty if so then error
        if [ -z "${boot_file_unpack_name}" ]; then
            red "boot_file_unpack_name is empty, but boot_file_unpack_cmd is specify\n"
            exit 1
        fi
        # prepare path - this is full path, must already exist in filesystem
        boot_file_unpack_name=$(prepare_path "${boot_file_unpack_name}" 0)
        # check whether boot_file_unpack_name exist - if not then run unpack cmd
        if [ ! -f "${boot_file_unpack_name}" ]; then
            # prepare and run unpack cmd
            boot_file_unpack_cmd=$(prepare_path "${boot_file_unpack_cmd}" 0)
            printf "${boot_file_unpack_cmd}\n"
            eval "${boot_file_unpack_cmd}"
        fi
        local boot_file_src_file="${boot_file_unpack_name}"
    fi

    # process convert from raw
    if [ $boot_file_convert_from_raw -eq 1 ]; then
        VBoxManage convertfromraw "${boot_file_src_file}" "${boot_file}" --format "${disk_format}"
        if [ $keep_boot_src_file -eq 0 ]; then
            rm -f "${boot_file_src_file}"
        fi
    else
        # check whether full path to boot_file_src_file is same as boot_file and boot_file was already created
        if [ -f "${boot_file}" ]; then
            return
        fi
        # check whether cp or mv; mv mean don't keep boot_file_src_file; keep only boot_file
        if [ $keep_boot_src_file -eq 0 ]; then
            mv -f "${boot_file_src_file}" "${boot_file}"
        else
            cp "${boot_file_src_file}" "${boot_file}"
        fi
    fi
}

# Prepare ssh keys
function get_priv_ssh_key {
    # check whether keys dir exist
    if [ ! -d "${ssh_keys_path}" ]; then
        printf "Creates vbkick ssh keys directory\n"
        mkdir "${ssh_keys_path}"
    fi
    # check whether private key exist
    if [ ! -f "${ssh_keys_path}/${ssh_priv_key}" ]; then
        curl "${ssh_priv_key_src}" -o "${ssh_keys_path}/${ssh_priv_key}"
    fi
    # change ssh key permissions - too open private key will be ignored
    chmod 600 "${ssh_keys_path}/${ssh_priv_key}"
}

function build_vm {
    # check whether VM already exist
    if VBoxManage list vms | grep -qw "${VM}"; then
        red "${VM} already exist\n"
        exit 1
    fi
    # load vm description/definition
    load_definition 
    # get ssh private key
    if [ $ssh_keys_enabled -eq 1 ]; then
        get_priv_ssh_key
    fi
    # download boot/iso files
    download_boot_media
    download_guest_additions_media
    # create VM box with given settings
    create_box
    # start simple webserver (in background)
    start_web_server
    # host ip to connect from guest
    local host_ip=10.0.2.2
    # start VM
    if [ $gui_enabled -eq 1 ]; then
        VBoxManage startvm --type gui "${VM}"  && sleep $boot_wait
    else
        VBoxManage startvm --type headless "${VM}" && sleep $boot_wait
    fi
    # boot VM machine
    for boot_cmd in "${boot_cmd_sequence[@]}"; do
        if [ -z "${boot_cmd}" ]; then 
            continue
        fi
        boot_cmd=${boot_cmd//%IP%/$host_ip}
        boot_cmd=${boot_cmd//%PORT%/$kickstart_port}
        boot_cmd=${boot_cmd//%NAME%/${VM}}
        printf "${boot_cmd}\n"
        # converts string to scancode via external python script
        local boot_cmd_code=$(printf "${boot_cmd}" | convert_2_scancode.py)
        # sends code to VM
        for code in $boot_cmd_code; do
            if [ "${code}" == "wait" ]; then
                sleep 1
            else
                VBoxManage controlvm "${VM}" keyboardputscancode $code
                sleep 0.02
            fi
        done
        sleep $boot_seq_wait
    done

    # wait until machine will be ready (ssh connection start working) or timeout was reached
    kickstart_monitoring

    # stop webserver
    stop_web_server

    exit 0
}

function create_box {
    # Register vm
    VBoxManage createvm --name "${VM}" --ostype "${os_type_id}" --register

    # Creates disks
    # Get default location for disks
    local location=$(VBoxManage list  systemproperties | grep "Default machine folder" | cut -d':' -f 2 | sed 's/^ *//g')

    # SATA controller - place for hdd and iso files
    # SATA controller allow add 30 disks, but vbkick reserve port 0 for boot media and port 1 for guest additions
    # check disk_size lenght
    if [ ${#disk_size[@]} -gt 28 ]; then
        red "Too many disks in disk_size (limited to 28 disks)\n"
        exit 1; 
    fi
    VBoxManage storagectl "${VM}" --name "SATA Controller"\
    --add sata --hostiocache $hostiocache --sataportcount $((${#disk_size[@]}+2))
    # SATA controller - add boot media
    VBoxManage storageattach "${VM}" --storagectl "SATA Controller"\
    --type "${boot_file_type}" --port 0 --device 0 --medium "${boot_file}"
    # SATA controller - create and add hdd disks
    local port_nr=2
    for disk in "${disk_size[@]}"; do
        if [ -z "${disk}" ]; then 
            continue
        fi
        VBoxManage createhd --filename "${location}/${VM}/${VM}-${port_nr}.${disk_format}"\
        --size $disk --format "${disk_format}" --variant Standard
        VBoxManage storageattach "${VM}" --storagectl "SATA Controller"\
        --port $port_nr --device 0 --type hdd --medium "${location}/${VM}/${VM}-${port_nr}.${disk_format}"
        local port_nr=$((port_nr+1))
    done
    # SATA controller - add VBoxGuestAdditions iso
    if [ $guest_additions_attach -eq 1 ]; then
        if [ ! -z "${guest_additions_path}" ]; then
            # custom VBoxGuestAdditions
            VBoxManage storageattach "${VM}" --storagectl "SATA Controller"\
            --type dvddrive --port 1 --device 0 --medium "${guest_additions_path}/VBoxGuestAdditions_${vb_version}.iso"
        else
            # default VBoxGuestAdditions
            VBoxManage storageattach "${VM}" --storagectl "SATA Controller"\
            --type dvddrive --port 1 --device 0 --medium emptydrive
            VBoxManage storageattach "${VM}" --storagectl "SATA Controller"\
            --type dvddrive --port 1 --device 0 --medium additions
        fi
    fi

    # Tuning VM
    # setting cpu's
    VBoxManage modifyvm "${VM}" --cpus $cpu_count
    # setting memory size
    VBoxManage modifyvm "${VM}" --memory $memory_size
    # setting video memory size
    VBoxManage modifyvm "${VM}" --vram $video_memory_size
    # setting bootorder
    VBoxManage modifyvm "${VM}" --boot1 disk --boot2 dvd --boot3 none --boot4 none
    # other settings
    for option in "${vm_options[@]}"; do
        local key="${option%%:*}"
        local value="${option##*:}"
        VBoxManage modifyvm "${VM}" --"${key}" "${value}"
    done

    # ssh NAT mapping
    # TODO [MEDIUM]: allow mapping more ports (nat_mapping_array)
    # list may be empty (check whether is empty or not..); ssh is special port
    if [[ ! `VBoxManage showvminfo "${VM}" | grep "vbkickSSH"` ]]; then
        # TODO [LOW]: check whether ssh_host_port is already in use and take other (random from list/range)
        VBoxManage controlvm "${VM}" natpf1 "vbkickSSH,tcp,,${ssh_host_port},,${ssh_guest_port}"
    fi

    # add shared folders
    # TODO [MEDIUM]: allow share more folders (shared_folders_array) %PWD%, etc
    if [ -n "${shared_folder}" ]; then 
        VBoxManage sharedfolder add  "${VM}" --name "${shared_folder}" --hostpath "`pwd`" --automount
    fi
    # natmapping_was_removed+1; sharedfolder_was_removed+1 - retore one by one after export. (Note: remove or not during export ?)
}

# Check whether machine was kickstarted before timeout
function kickstart_monitoring {
    local kickstart_counter=0
    local extra_ssh_options="-o ConnectionAttempts=1 -o ConnectTimeout=1"
    # ssh key authentication enabled
    if [ $ssh_keys_enabled -eq 1 ]; then        
        # create path to ssh private key
        local key_path="${ssh_keys_path}/${ssh_priv_key}"
        printf "\nWaiting for ssh login with user ${ssh_user} to localhost:${ssh_host_port} to work, kickstart_timeout=${kickstart_timeout} sec\n"
        # wait until ssh start working (communication chanel with VM) or kickstart_timeout was reached
        while [[ ! `ssh "${ssh_user}@localhost" -q -t -i ${key_path} -p $ssh_host_port $ssh_options $extra_ssh_options -C "echo"`\
            && $kickstart_counter -le $kickstart_timeout ]]; do
            kickstart_counter=$((kickstart_counter+1))
            printf "."
            sleep 1
        done
        printf "\n"
    else
        # if no ssh key authentication enabled then wait until timeout will be reached
        printf "Sleeping ${kickstart_timeout} seconds ...\n"
        sleep $kickstart_timeout
    fi
}

function destroy_vm {
    # check whether VM already exist
    if [[ ! `VBoxManage list vms | grep -w "${VM}"` ]]; then
        red "${VM} doesn't exist\n"
        exit 1
    fi

    # destroy VM
    printf "Destroy ${VM}\n"
    read -r -p "Are you sure? [y/N]" ans
    if [[ ! $ans =~ ^[Yy]$ ]]; then
        exit 1
    fi

    # check whether VM is running
    if [[ `VBoxManage list runningvms | grep -w "${VM}"` ]]; then
        printf "Poweroff ${VM}\n"
        VBoxManage controlvm "${VM}" poweroff
        sleep 1
    fi

    printf "Destroying...\n"
    VBoxManage unregistervm "${VM}" --delete
    exit 0
}

function export_vm {
    #
    # basic replacement for that vagrant command:
    # vagrant package --base "${VM}" --output "${VM}.box"
    # if more customisation required use: vagrant package (--help)
    #
    # load vm description/definition
    load_definition
    # check whether VM_NAME.box exist in current dir
    if [ -f "${VM}.box" ]; then
        red "${VM}.box already exist in `pwd`\n"
        exit 1
    fi
    # check whether VM exist
    if [[ ! `VBoxManage list vms | grep -w "${VM}"` ]]; then
        red "${VM} doesn't exist\n"
        exit 1
    fi
    # check whether VM is running and shutdown it 
    shutdown

    # clearing previously set port forwarding rules (only if exist)
    if [[ `VBoxManage showvminfo "${VM}" | grep -w "vbkickSSH"` ]]; then
        VBoxManage modifyvm "${VM}" --natpf1 delete "vbkickSSH"
        natmapping_was_removed=1
    fi
    
    # rm shared folder (only if exist)
    if [[ `VBoxManage showvminfo "${VM}" | grep -w 'machine mapping' | grep -w "Name: '${shared_folder}'"` ]]; then
        VBoxManage sharedfolder remove  "${VM}" --name "${shared_folder}"
        sharedfolder_was_removed=1
    fi

    # create tmp_dir for export data
    tmp_dir=$(mktemp -d --tmpdir=.)
    # export VM to tmp_dir
    VBoxManage export "${VM}" --output "${tmp_dir}/box.ovf"
    # get VM MAC Address
    local mac_address=$(VBoxManage showvminfo --details --machinereadable "${VM}"\
    | grep macaddress1 | cut -d"=" -f 2)
    # add Vagrantfile
    printf "Vagrant.configure(\"2\") do |config|
    \t# This Vagrantfile is auto-generated by \`vagrant package\` to contain
    \t# the MAC address of the box. Custom configuration should be placed in
    \t# the actual \`Vagrantfile\` in this box.
    \tconfig.vm.base_mac = ${mac_address}
    end\n
    # Load include vagrant file if it exists after the auto-generated
    # so it can override any of the settings
    include_vagrantfile = File.expand_path(\"../include/_Vagrantfile\", __FILE__)
    load include_vagrantfile if File.exist?(include_vagrantfile)\n" > "${tmp_dir}/Vagrantfile"
    # add metadata.json
    printf "{\"provider\":\"virtualbox\"}\n" > "${tmp_dir}/metadata.json"
    # create VM_NAME.box (gzip) file
    cd $tmp_dir && tar -cvzf "${VM}.box" * && cd ..
    mv "${tmp_dir}/${VM}.box" .
    # remove tmp_dir
    rm -rf $tmp_dir
    # help recover some changes made on VM during exporting
    recover_vm_state
    printf "Done: `pwd`/${VM}.box\n"
    exit 0
}

function recover_vm_state {
    # add NAT mapping after exporting - only if exist prev.
    if [ $natmapping_was_removed -eq 1 ]; then
        VBoxManage controlvm "${VM}" natpf1 "vbkickSSH,tcp,,${ssh_host_port},,${ssh_guest_port}"
        natmapping_was_removed=0
    fi
    # add shared folder after exporting - only if exist prev.
    if [ $sharedfolder_was_removed -eq 1 ]; then
        VBoxManage sharedfolder add  "${VM}" --name "${shared_folder}" --hostpath "`pwd`" --automount
        sharedfolder_was_removed=0
    fi
}

function turn_on {
    # check whether VM is already running
    if [[ `VBoxManage list runningvms | grep -w "${VM}"` ]]; then
        # nothing to do
        green "${VM} is already running...\n"
        exit 0
    fi
    
    # check whether VM already exist
    if [[ ! `VBoxManage list vms | grep -w "${VM}"` ]]; then
        red "${VM} doese not exist. Use \"vbkick build\" to create the new VM.\n"
        exit 1
    fi

    VBoxManage startvm --type gui "${VM}"
}

function turn_off {
    # check whether VM is running 
    if [[ ! `VBoxManage list runningvms | grep -w "${VM}"` ]]; then
        green "${VM} is already turn off.\n"
        exit 0
    fi

    # load vm description/definition
    load_definition 

    #exec shutdown
    shutdown
}

function shutdown {

    # check whether VM is running and exec shutdown_cmd via SSH
    if [[ `VBoxManage list runningvms | grep -w "${VM}"` ]]; then
        printf "Shutting down ${VM} "
        if [ $ssh_keys_enabled -eq 1 ]; then        
            # ssh key authentication enabled
            # if key not exist then get it
            get_priv_ssh_key
            # create path to ssh private key
            local key_path="${ssh_keys_path}/${ssh_priv_key}"
            ssh "${ssh_user}@localhost" -q -t -i ${key_path} -p $ssh_host_port $ssh_options -C "${shutdown_cmd}" || true
        else
            auto_passwd_ssh "${shutdown_cmd}"
        fi
        # wait until VM is down or shutdown_timeout was reached
        local shutdown_counter=0
        while [[ `VBoxManage list runningvms | grep -w "${VM}"` && $shutdown_counter -le $shutdown_timeout ]]; do
            shutdown_counter=$((shutdown_counter+1))
            printf "."
            sleep 1
        done
    fi

    # check whether VM is still running, if so use acpipowerbutton
    if [[ `VBoxManage list runningvms | grep -w "${VM}"` ]]; then
        VBoxManage controlvm "${VM}" acpipowerbutton
        printf "\n${VM} - acpipowerbutton was used. Waiting $shutdown_timeout seconds...\n"
        sleep $shutdown_timeout
    else
        printf "\n${VM} was shutdown cleanly.\n"
        sleep 3
        return
    fi

    # check whether VM is still running, if so poweroff it using hard way.
    if [[ `VBoxManage list runningvms | grep -w "${VM}"` ]]; then
        VBoxManage controlvm "${VM}" poweroff
        printf "\n${VM} was powered off.\n"
        sleep 3
    else
        printf "\n${VM} was shutdown cleanly.\n"
        sleep 3
    fi
}

function update_guest_additions_media {
    # get current guest version
    if [[ `VBoxManage guestproperty enumerate "${VM}" | grep "GuestAdd/Version"` ]]; then
        # guest already exist, get current version
        local guest_version=$(VBoxManage guestproperty get "${VM}" "/VirtualBox/GuestAdd/Version" | cut -f 2 -d " ")
    else
        # guest doesn't exist
        local guest_version=""
    fi
    
    # check whether we need update or install VBoxGuestAdditions
    if [ "${vb_version}" != "${guest_version}" ]; then
        # TODO [LOW]: use Storage Controller Name (1) and type to find controller name
        # check whether "SATA Controller (1, 0)" exist - require to attach iso and creates /dev/sr1 or /dev/sr0
        if [[ ! `VBoxManage showvminfo "${VM}" | grep -w "SATA Controller (1, 0)"` ]]; then
            red "\"SATA Controller (1, 0)\" for \"${VM}\" doesn't exist.\n"
            red "\"SATA Controller\" is sata controller name used by vbkick.\n"
            red "More: 'VBoxManage showvminfo \"${VM}\" | grep -w \"Controller\"'\n"
            red "\nTo create proper controller use:\n"
            red "'VBoxManage storagectl \"${VM}\" --name \"SATA Controller\" --add sata --hostiocache $hostiocache --sataportcount $((${#disk_size[@]}+2))'\n"
            red "'VBoxManage storageattach \"${VM}\" --storagectl \"SATA Controller\" --type dvddrive --port 1 --device 0 --medium emptydrive'\n"
            red "\nTo do this \"${VM}\" must be shutdown !!! \nRemember - VM Guest may have only one sata controller.\n"
            exit 1
        fi
        # Attach new VBoxGuestAdditions to install
        # vbkick creates VM with SATA Controller port 1 available for VBoxGuestAdditions iso.
        if [ ! -z "${guest_additions_path}" ]; then
            # custom VBoxGuestAdditions
            download_guest_additions_media
            VBoxManage storageattach "${VM}" --storagectl "SATA Controller"\
            --type dvddrive --port 1 --device 0 --medium "${guest_additions_path}/VBoxGuestAdditions_${vb_version}.iso" --forceunmount
        else
            # default VBoxGuestAdditions
            VBoxManage storageattach "${VM}" --storagectl "SATA Controller"\
            --type dvddrive --port 1 --device 0 --medium additions --forceunmount
        fi
        # Note: Guest OS (Linux) does not support automatic Guest Additions updating: 
        # VBoxManage guestcontrol <vmname>|<uuid> updateadditions
        # Manuall Guest Additions update/installation is required (via lazy_update cmd).
    else
        green "VBoxGuestAdditions on ${VM} is up-to-date - update media iso is not needed\n"
    fi
}

function validate_vm {
    #
    # test should be smart enough to check what I really want to test
    # e.g. If I don't need chef, don't test whether I have chef
    #
    # load vm description/definition
    load_definition
    # exec scripts on VM Guest via ssh
    ssh_exec ${#validate_transport[@]} "${validate_transport[@]}" "${validate_launch[@]}"
    exit 0
}

function lazy_postinstall {
    # load vm description/definition
    load_definition
    # exec scripts on VM Guest via ssh
    ssh_exec ${#postinstall_transport[@]} "${postinstall_transport[@]}" "${postinstall_launch[@]}"
    exit 0
}

function lazy_update {
    # load vm description/definition
    load_definition
    # Check whether VBoxGuestAdditions should be installed. If not then not update additions.
    if [ $guest_additions_attach -eq 1 ]; then
        update_guest_additions_media
    fi
    # Run other update scripts on VM Guest via ssh
    ssh_exec ${#update_transport[@]} "${update_transport[@]}" "${update_launch[@]}"
    exit 0
}

function ssh_exec {
    #
    # transport scripts to VM Guest via SCP and exec them via SSH
    #
    # get number of transport files/directories; transport array length
    local pos=$1
    shift
    # get transport array; everything to $pos
    local transport=("${@:1:$pos}")
    shift $pos
    # get launch array;
    local launch=("${@}")

    # check whether VM is running 
    if [[ ! `VBoxManage list runningvms | grep -w "${VM}"` ]]; then
        red "${VM} is not running...\n"
        exit 1
    fi

    # checking port forwarding (if no proper rules, try add new one for NAT mapping)
    if [[ ! `VBoxManage showvminfo "${VM}" | grep "NIC 1" | grep "host port = ${ssh_host_port}"\
        | grep "guest port = ${ssh_guest_port}"` ]]; then
        printf "NAT mapping - enable ssh port forwarding\n"
        VBoxManage controlvm "${VM}" natpf1 "vbkickSSH,tcp,,${ssh_host_port},,${ssh_guest_port}"
    fi

    # ssh key authentication enabled
    if [ $ssh_keys_enabled -eq 1 ]; then        
        # if key not exist then get it
        get_priv_ssh_key
        # create path to ssh private key
        local key_path="${ssh_keys_path}/${ssh_priv_key}"
    fi

    # transport scripts to guest
    for pkt in "${transport[@]}"; do
        if [ -z "${pkt}" ]; then 
            continue
        fi
        printf "Scp: ${pkt}\n"
        # check whether pkt is file or dir
        if [[ -d "${pkt}" ]]; then
            # pkt is directory
            if [ $ssh_keys_enabled -eq 1 ]; then        
                scp -q -P $ssh_host_port -i "${key_path}" $ssh_options -r "${pkt}" "${ssh_user}@localhost:~${ssh_user}"
            else
                # 1 mean scp directory (recursive)
                auto_passwd_scp "${pkt}" 1
            fi
        elif [[ -f "${pkt}" ]]; then
            # pkt is file
            if [ $ssh_keys_enabled -eq 1 ]; then        
                scp -q -P $ssh_host_port -i "${key_path}" $ssh_options "${pkt}" "${ssh_user}@localhost:~${ssh_user}"
            else
                # 0 mean scp file
                auto_passwd_scp "${pkt}" 0
            fi
        else
            # pkt is neither file nor directory
            red "${pkt} is neither file nor directory\n"
            exit 1
        fi
        sleep 1
    done

    # run commands via ssh
    for cmd in "${launch[@]}"; do
        if [ -z "${cmd}" ]; then 
            continue
        fi
        # %HOST% tag - check whether command should be executed on host (not guest)
        if [[ "${cmd}" =~ ^\ *%HOST% ]]; then
            # extract command
            cmd=${cmd//%HOST%/}
            printf "Exec (on host): ${cmd}\n"
            eval "${cmd}"
            continue
        fi
        printf "Exec: ${cmd}\n"
        # true is used because fail is accepted
        if [ $ssh_keys_enabled -eq 1 ]; then
            ssh -q "${ssh_user}@localhost" -t -i ${key_path} -p $ssh_host_port $ssh_options -C "${cmd}" || true
        else
            auto_passwd_ssh "${cmd}"
        fi
        sleep 1
    done
    
    # clean after scp by rm transported media/scripts
    # TODO [MEDIUM]: better cleaning - scp dir1/dir2/file creates file not full structure
    if [ $clean_transported -eq 1 ]; then
        for pkt in "${transport[@]}"; do
            if [ -z "${pkt}" ]; then 
                continue
            fi
            printf "Clean transported: ${pkt}\n"
            if [ $ssh_keys_enabled -eq 1 ]; then        
                ssh -q "${ssh_user}@localhost" -t -i ${key_path} -p $ssh_host_port $ssh_options -C "cd ~${ssh_user} && rm -rf ${pkt}" || true
            else
                auto_passwd_ssh "cd ~${ssh_user} && rm -rf ${pkt}"
            fi
            sleep 1
        done
    fi
}

function lazy_ssh {
    # check whether VM is running 
    if [[ ! `VBoxManage list runningvms | grep -w "${VM}"` ]]; then
        red "${VM} is not running...\n"
        exit 1
    fi
    # load vm description/definition
    load_definition
    if [ $ssh_keys_enabled -eq 1 ]; then        
        # if key not exist then get it
        get_priv_ssh_key
        # create path to ssh private key
        local key_path="${ssh_keys_path}/${ssh_priv_key}"
        ssh -q "${ssh_user}@localhost" -t -i ${key_path} -p $ssh_host_port $ssh_options
    else
        auto_passwd_ssh ""
    fi
}

function auto_passwd_ssh {
    local _cmd="${1}"
    if [[ `which expect 2>/dev/null` ]]; then
        if [ -z "${_cmd}" ]; then
            # No cmd to exec, interactive shell
            local _expect_cmd="ssh -q \"${ssh_user}@localhost\" -t -p $ssh_host_port $ssh_options"
        else
            local _expect_cmd="ssh -q \"${ssh_user}@localhost\" -t -p $ssh_host_port $ssh_options -C \"${_cmd}\""
        fi
        expect -c "spawn $_expect_cmd; expect password ; send \"$ssh_password\n\" ; interact"
    else
        yellow "WARNING: 'expect' command not exist - install 'expect' to automate ssh authentication without ssh_key.\n"
        yellow "To use ssh_key authentication setup ssh_keys_enabled=1 in your definition.cfg\n"
        # Process without expect
        if [ -z "$_cmd" ]; then
            # No cmd to exec, interactive shell
            ssh -q "${ssh_user}@localhost" -t -p $ssh_host_port $ssh_options || true
        else
            ssh -q "${ssh_user}@localhost" -t -p $ssh_host_port $ssh_options -C "${cmd}" || true
        fi
    fi
}

function auto_passwd_scp {
    #echo "Not implemented yet !"
    local _src="${1}"
    local _recursive="${2}"
    if [[ `which expect 2>/dev/null` ]]; then
        if [ $_recursive -eq 1 ]; then
            local _expect_cmd="scp -q -P $ssh_host_port $ssh_options -r \"${_src}\" \"${ssh_user}@localhost:~${ssh_user}\""
        else
            local _expect_cmd="scp -q -P $ssh_host_port $ssh_options \"${_src}\" \"${ssh_user}@localhost:~${ssh_user}\""
        fi
        expect -c "spawn $_expect_cmd; expect password ; send \"$ssh_password\n\" ; interact"
    else
        yellow "WARNING: 'expect' command not exist - install 'expect' to automate ssh authentication without ssh_key.\n"
        yellow "To use ssh_key authentication setup ssh_keys_enabled=1 in your definition.cfg\n"
        # Process without expect
        if [ $_recursive -eq 1 ]; then
            scp -q -P $ssh_host_port $ssh_options -r "${_src}" "${ssh_user}@localhost:~${ssh_user}"
        else
            scp -q -P $ssh_host_port $ssh_options "${_src}" "${ssh_user}@localhost:~${ssh_user}"
        fi
    fi
}

function start_web_server {
    # check whether port is not used by other proc
    if nc -z localhost $kickstart_port; then
        red "$kickstart_port port is already in use\n"
        # TODO [LOW]: choose next webserver port if present is in use from kickstart_port list, 
        # and update current_kickstart_port - this not working with injection method (list of files to update ?)
        exit 1
    fi
    # start simple webserver serving files in background
    py_version=$(python -V 2>&1 | cut -d' ' -f 2 | cut -d'.' -f 1)
    if [[ $py_version -eq 2 ]]; then
        webserver_module="SimpleHTTPServer"
    elif [[ $py_version -eq 3 ]]; then
        webserver_module="http.server"
    else
        red "Unknown python version\n"
        exit 1
    fi
    python -m $webserver_module $kickstart_port &
    # get the pid already spawned process, to kill it later
    web_pid=$!
    sleep 2
    # check whether web server was really started
    if ! nc -z localhost $kickstart_port; then
        red "webserver was not started\n"
        exit 1
    fi
    # update webserver_status variable
    webserver_status=1
}

function stop_web_server {
    # check whether webserver is running
    if [ $webserver_status -ne 0 ]; then
        printf "Stopping webserver...\n"
        # with "set -e -E" if kill command fail then ERR trap is processing 
        # simply execution of function is not continued
        webserver_kill_status=1
        kill $web_pid
        webserver_kill_status=0
        # kill command is sucessfull when SIGTERM is sent to running process
        # not when child process was really killed
        if [[ ! `ps -ef | grep "python -m $webserver_module $kickstart_port" | grep -v grep` ]]; then
            printf "INFO: webserver was stopped\n"
        else
            yellow "WARNING: problem with stopping webserver. Kill proces manually\n"
            ps -ef | grep "python -m $webserver_module $kickstart_port" | grep -v grep
        fi
        # update webserver_status variable
        webserver_status=0
    fi
}

# (signals and error handler) - cleaning after ctr-c, etc.
function clean_up {
    printf "INFO: Signal/Error handler - cleanup before exiting...\n"
    if [ $webserver_kill_status -eq 0 ]; then
        # stop webserver (only if stop_web_server function didn't fail previuosly)
        stop_web_server
    else
        # previuosly executed stop_web_server function fail in killing $web_pid
        yellow "WARNING: problem with killing webserver (proc ${web_pid}). Kill proces manually\n"
    fi
    # help recover some changes made on VM during exporting
    recover_vm_state
    # clean tmp_dir if exist
    if [ -d $tmp_dir ]; then
        rm -rf $tmp_dir
    fi
    exit 1
}

function depend_check {
    local dep_cmd="${1}"
    local dep_name="${2}"
    # check whether dep_name is installed - dep_cmd command exist
    if [[ ! `which $dep_cmd 2>/dev/null` ]]; then
        red "$dep_cmd command not exist - install $dep_name to continue\n"
        exit 1
    fi
}

function dependencies_check {
    depend_check "VBoxManage" "Virtualbox"
    depend_check "curl" "curl"
    depend_check "ssh" "ssh-client (e.g. openssh-client)"
    depend_check "scp" "scp-client (e.g. openssh-client)"
    depend_check "python" "python"
    depend_check "nc" "netcat"
    depend_check "python" "python"
}

## MAIN ##
# exactly 2 Args required - ACTION VM_NAME
if [ $# -ne 2 ]; then
    usage
    exit 1
fi

# check whether we have everything to start with vbkick
dependencies_check

vb_version=$(get_vb_version)
# signals and error handler
trap clean_up SIGHUP SIGINT SIGTERM ERR
process_args "${1}" "${2}"
