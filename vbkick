#!/bin/bash

# The MIT License - https://github.com/wilas/vbkick/blob/master/LICENSE

# Helps build Virtualbox guest VMs and Vagrant base boxes.

# Secure bash
# More about options: http://wiki.bash-hackers.org/commands/builtin/set
# treat unset variables as an error
set -u;
# exit when cmd fail (use ERR trap for clean exit)
set -e; set -E;
# fail the entire pipeline if any part of it fails
set -o pipefail;
# debug mode
#set -x;
# http://mywiki.wooledge.org/glob
shopt -s failglob;
# enable POSIX mode
# http://www.gnu.org/software/bash/manual/html_node/Bash-POSIX-Mode.html
set -o posix

# VM default settings - basic
hostiocache="on"
cpu_count=1
memory_size=512
disk_size=(10140)
disk_format="vdi"
video_memory_size=10
# default nic type: Intel PRO/1000 MT Desktop (82540EM); recommended - virtio
# more to choose Am79C970A|Am79C973|82540EM|82543GC|82545EM|virtio
# http://www.virtualbox.org/manual/ch06.html#nichardware
nic_type="82540EM"
# list of VM options: ("option1:value" "option2:value")
vm_options=("ioapic:on")
# list of VM extradata to set: ("extradata:value" "extradata:value")
vm_extradata=("")
# by default gui enabled unless the VirtualBox GUI is missing
gui_enabled=1
if ! command -v VirtualBox >/dev/null 2>&1; then
    gui_enabled=0
fi
# by default add one shared folder - to disable: shared_folders=("")
shared_folders=("vbkick:%PWD%:automount")
# by default no extra ports is mapping
extra_ports=("")

# Guest Additions default settings
# set to 0 to not attach VBoxGuestAdditions iso to guest
guest_additions_attach=1
# path where guest_additions should be download, if empty then not download custom VBoxGuestAdditions to host, use default one
guest_additions_path=""

# Boot default settings
#boot_file -> required option, fail if not in definition
#boot_file_src -> required option, fail if not in definition
# type of boot media e.g.: hdd, dvddrive; by default dvddrive
boot_file_type="dvddrive"
# default path for src media needed to create destination boot_file
boot_file_src_path="iso"
# by default checksum is empty - checksum is not check
boot_file_src_checksum=""
# default cheksum type is sha256
boot_file_checksum_type="sha256"
# by default unpacke is not needed
boot_file_unpack_cmd=""
# where is the path and the filename after unpack
boot_file_unpack_name=""
# is boot_file_src raw image and need to be converted
boot_file_convert_from_raw=0
# whether use cp or mv when boot_file is created form boot_file_src_file;
# mv mean don't keep boot_file_src_file; keep only boot_file; by default 0 - use mv
keep_boot_src_file=0
# default time before boot_cmd_sequence start
boot_wait=10
# list of boot_cmd: ("cmd1" "cmd2" "cmd3")
boot_cmd_sequence=("")
# default number of second wait between each boot_cmd
boot_seq_wait=1
# default webserver port to serve kickstart files
kickstart_port=7122
# default max webserver live time
kickstart_timeout=7200
# do not start local webserver, by default 0 - mean start webserver to serve files from current dir.
webserver_disabled=0

# SSH default settings (veeded to run vbkick validate and/or lazy_posinstall)
# by default use ssh keys
ssh_keys_enabled=1
# default user
ssh_user="vbkick"
# default user password - not use when ssh_keys authentication is enabled
ssh_password="vbkick"
# default path to ssh keys
ssh_keys_path="keys"
# default private key name
ssh_priv_key="vbkick_key"
# default auto-download path
ssh_priv_key_src="https://raw.github.com/wilas/vbkick/master/keys/vbkick_key"
# default ssh host port
ssh_host_port=2222
# default (22) ssh guest port to forwarding
ssh_guest_port=22
# default "vbkickSSH"
ssh_port_name="vbkickSSH"
# default extra ssh and scp options
# UserKnownHostsFile - database file to use for storing the user host keys
# StrictHostKeyChecking - if "no" then automatically add new host keys to the host key database file
# you may consider editing ssh config: http://superuser.com/questions/141344/ssh-dont-add-hostkey-to-known-hosts
ssh_options="-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o NumberOfPasswordPrompts=1"

# Lazy Postinstall default settings
# list of files and directories to transport to guest
postinstall_transport=("")
# list of postinstall commands
postinstall_launch=("")

# Validate default settings
# list of files and directories to transport to guest
validate_transport=("")
# list of validate commands
validate_launch=("")

# Lazy Update default settings
# list of files and directories to transport to guest
update_transport=("")
# list of update commands
update_launch=("")

# Clean
# list of files to autoupdate VBOX_VERSION value
files_to_autoupdate_vbox_version=("")
# rm or not already transported via SCP files/directories (from postinstall, validate)
clean_transported=0
# nice for OS shutdown command
shutdown_cmd="sudo /sbin/halt -h -p"
# when timeout is reached and VM is still running, hard poweroff is used
shutdown_timeout=20

# Other global variables - do not use it in definition.cfg (will be overwrite during program runtime)
# default definition file
definition_fname="definition.cfg"
# virtual machine name
VM=""
# 0 - webserver is not running or kill isn't able to stop it
webserver_status=0
# 0 - webserver was killed cleanly or we didn't try kill it yet
webserver_kill_cmd_status=0
# during exporting tmp directory is created
tmp_dir=""
# during exporting NAT mapping is removed (temporary) - help recover state before exporting
ssh_natmapping_was_removed=0
# during exporting shared folders are removed (temporary) - help recover state before exporting
sharedfolders_removed_ptr=0
# during exporting extra ports are removed (temporary) - help recover state before exporting
extraports_removed_ptr=0

# For nice printing
GREEN="\e[1;32m"
RED="\e[1;31m"
YELLOW="\e[1;33m"
NORMAL="\e[0m"
log_info() {
    printf "[INFO] $*\n"
}
log_ginfo() {
    printf "$GREEN[INFO] $*$NORMAL\n"
}
log_warning() {
    printf "$YELLOW[WARNING] $*$NORMAL\n"
}
log_error() {
    printf "$RED[ERROR] $*$NORMAL\n" >&2
}

# Display help
usage() {
    printf "Desc: the automatic Virtualbox Guests and Vagrant Base Boxes builder\n"
    printf "\n"
    printf "Usage: $0 ACTION VM_NAME (DEFINITION_FILE_NAME)\n"
    printf "\n"
    printf "Available actions:\n"
    printf "\tbuild                 build VM\n"
    printf "\tpostinstall           run postinstall scripts via ssh\n"
    printf "\tvalidate              run validate/feature scripts via ssh\n"
    printf "\texport                export VM and creates Vagrant VM_NAME.box\n"
    printf "\tupdate                run update scripts via ssh\n"
    printf "\tdestroy               destroy VM\n"
    printf "\tssh                   ssh to VM\n"
    printf "\ton                    turn on VM\n"
    printf "\tshutdown              shutdown VM\n"
    printf "\thelp                  display this help and exit\n"
    printf "\n"
}

# Cmd line parser, take 2 args
process_args() {
    VM="${2}"
    case "$1" in
        "build") build_vm ;;
        "destroy") destroy_vm ;;
        "export") export_vm ;;
        "validate") validate_vm ;;
        "postinstall") lazy_postinstall ;;
        "update") lazy_update ;;
        "ssh") lazy_ssh ;;
        "on") turn_on ;;
        "shutdown") turn_off ;;
        *) usage; exit ;;
    esac
}

# Help automatically update/maintain value of VBOX_VERSION in given files list
autoupdate_files_with_vbox_version() {
    for file in "${files_to_autoupdate_vbox_version[@]}"; do
        # check whether file is an empty string
        if [[ -z "${file}" ]]; then
            continue
        fi
        # check whether file exist
        if [[ -s "${file}" ]]; then
            # example value to update: VBOX_VERSION="4.2.12", but ignore comments
            sed -r -i "/^#/!s/(VBOX_VERSION)=\"([0-9\.]+)\"/\1=\"$vb_version\"/g" "${file}"
        else
            printf "VBOX_VERSION=\"$vb_version\"\n" > "${file}"
            printf "export VBOX_VERSION" >> "${file}"
        fi
    done
}

depend_check() {
    local dep_cmd="${1}"
    local dep_name="${@}"
    # check whether dep_name is installed - dep_cmd command exist
    if ! command -v $dep_cmd >/dev/null 2>&1; then
        log_error "${dep_cmd} command doesn't exist - install '${dep_name}' to continue."
        return 1
    fi
}

dependencies_check() {
    depend_check "VBoxManage" "Virtualbox"
    depend_check "curl" "curl"
    depend_check "ssh" "ssh-client (e.g. openssh-client)"
    depend_check "scp" "scp-client (e.g. openssh-client)"
    depend_check "python" "python"
    depend_check "bash" "bash"
    depend_check "openssl" "openssl"
}

check_required_options() {
    local opts=("boot_file" "boot_file_src" "os_type_id")
    for opt in "${opts[@]}"; do
        if [[ -z "${!opt+x}" ]]; then
            log_error "Required $opt option is not defined."
            return 1
        fi
    done
}

# Load definition.cfg config file; it overwrite default settings
load_definition() {
    if [[ -s "${definition_fname}" ]]; then
        # In POSIX mode the '.' and 'source' builtins do not search the current directory
        # for the filename argument if it is not found by searching PATH.
        log_info "Loading \"${definition_fname}\" definition..."
        . "./${definition_fname}"
    else
        log_error "Not existing or empty \"${definition_fname}\" file in `pwd`. Terminating..."
        return 1
    fi
    check_required_options
    autoupdate_files_with_vbox_version
}

# Get virtualbox version
get_vb_version() {
    local version=$(VBoxManage --version) # e.g. 4.2.12r84980
    local pos=$(expr "${version}" : '[0-9.]\+')
    local version=${version:0:$pos} #e.g. 4.2.12
    printf "${version}"
}

is_present() {
    VBoxManage list vms | grep -qw "${VM}"
}

is_running() {
    VBoxManage list runningvms | grep -qw "${VM}"
}

is_port_used() {
    local port_nr="${1}"
    # () is useful to be silent
    (printf "" > /dev/tcp/127.0.0.1/$port_nr) 2>/dev/null
}

is_port_present() {
    local port_name="${@}"
    VBoxManage showvminfo "${VM}" | grep -w 'guest port' | grep -qw "${port_name}"
}

is_shared_folder_present() {
    local folder_name="${@}"
    VBoxManage showvminfo "${VM}" | grep -w 'machine mapping' | grep -qw "Name: '${folder_name}'"
}

# checks whether port is not used by other proc
check_port_usage() {
    local port_nr="${1}"
    local port_message="${@}"
    if is_port_used $port_nr; then
        log_error "$port_nr port (${port_message}) is already used by an other process."
        return 1
    fi
}

# Check whether given directory exist
prepare_path() {
    local path="${1}"
    local mkdir_path="${2}"
    # Process special variables in path definition e.g. path="%VBOXFOLDER%/%NAME%"
    local location=$(VBoxManage list  systemproperties | grep "Default machine folder" | cut -d':' -f 2 | sed 's/^ *//g')
    local path=${path//%SRCPATH%/${boot_file_src_path}}
    local path=${path//%VBOXFOLDER%/${location}}
    local path=${path//%PWD%/`pwd`}
    # get homedir - `getent passwd UID` doesn't work for MacOS; $HOME is less portable than ~
    local path=${path//%HOME%/~}
    local path=${path//%NAME%/${VM}}
    # expand a special variable - e.g. tilde (~) and
    # strips out > characters which could clobber a file during the eval
    local path=$(eval echo "${path//>}")
    # Creates dir if necessary
    if [[ $mkdir_path -eq 1 ]] && [[ ! -z "${path}" ]] && [[ ! -d "${path}" ]]; then
        mkdir -p "${path}"
    fi
    # Return path
    printf "${path}"
}

curl_safe() {
    local src="${1}"
    local dest="${2}"
    local STATUSCODE=$(curl -Lkfw "%{http_code}\n" "${src}" -o "${dest}")
    if [[ $STATUSCODE -ne 200 ]]; then
        log_error "${src} status code is ${STATUSCODE}. Terminating..."
        clean_up
    fi
}

# Downloads custom VBoxGuestAdditions if required
download_guest_additions_media() {
    if [[ -z "${guest_additions_path}" ]]; then
        # nothing to do
        return
    fi
    guest_additions_path=$(prepare_path "${guest_additions_path}" 1)
    # check whether VBoxGuestAdditions exist
    if [[ ! -f "${guest_additions_path}/VBoxGuestAdditions_${vb_version}.iso" ]]; then
        local additions_url="http://download.virtualbox.org/virtualbox/${vb_version}/VBoxGuestAdditions_${vb_version}.iso"
        curl_safe "${additions_url}" "${guest_additions_path}/VBoxGuestAdditions_${vb_version}.iso"
    fi
    # rm useless images
    remove_guest_additions_media
}

# Remove other (not needed) VBoxGuestAdditions from media directory
remove_guest_additions_media() {
    if [[ -z "${guest_additions_path}" ]]; then
        # nothing to do
        return
    fi
    guest_additions_path=$(prepare_path "${guest_additions_path}" 0)
    # true is use to not fail whole cmd, and return empty string
    local file_list=$(ls "${guest_additions_path}" | grep "GuestAdditions" | grep -v "${vb_version}" || true)
    # continue only if we have some files to remove
    if [[ -z "${file_list}" ]]; then
        return
    fi
    log_info "List of VBoxGuestAdditions files to remove:"
    for file in ${file_list}; do
        printf "${file}\n"
    done
    # to remove files ask about confirmation
    read -r -p "Do you want remove above VBoxGuestAdditions files? [y/N]" ans
    if [[ $ans =~ ^[Yy]$ ]]; then
        for file in ${file_list}; do
            printf "${file}\n"
            rm -f "${guest_additions_path}/${file}"
        done
    fi
}

# Prepare installation/boot media
download_boot_media() {
    local boot_file_path=$(dirname "${boot_file}")
    local boot_file_name=$(basename "${boot_file}")
    local boot_file_path=$(prepare_path "${boot_file_path}" 1)
    boot_file="${boot_file_path}/${boot_file_name}"

    # check whether boot file exist
    if [[ -f "${boot_file}" ]]; then
        # file exist, nothing to do
        return
    fi

    # boot_file_src is empty (not defined)
    if [[ -z "${boot_file_src}" ]]; then
        log_error "${boot_file} not exist and boot_file_src is empty"
        return 1
    fi

    # the temporary name for boot_file is last part from boot_file_src
    local tmp_name=$(basename "${boot_file_src}")
    boot_file_src_path=$(prepare_path "${boot_file_src_path}" 1)
    local boot_file_src_file="${boot_file_src_path}/${tmp_name}"
    # check whether boot_file_src exist
    if [[ ! -f "${boot_file_src_file}" ]]; then
        curl_safe "${boot_file_src}" "${boot_file_src_file}"
    fi

    # verify boot_file_src checksum if boot_file_src_checksum is provided
    if [[ ! -z "${boot_file_src_checksum}" ]]; then
        local get_checksum=$(openssl "${boot_file_checksum_type}" "${boot_file_src_file}" | cut -d" " -f 2)
        if [[ "${boot_file_src_checksum}" != "${get_checksum}" ]]; then
            log_warning "CHECKSUM is different then expected !"
            read -r -p "Do you want continue? [y/N]" ans
            if [[ ! $ans =~ ^[Yy]$ ]]; then
                return 1
            fi
        else
            log_info "CHECKSUM:${boot_file_src_checksum} is valid."
        fi
    fi

    # process unpack
    if [[ ! -z "${boot_file_unpack_cmd}" ]]; then
        # check whether boot_file_unpack_name is empty if so then error
        if [[ -z "${boot_file_unpack_name}" ]]; then
            log_error "boot_file_unpack_name is empty, but boot_file_unpack_cmd is specify"
            return 1
        fi
        # prepare path - this is full path, must already exist in filesystem
        boot_file_unpack_name=$(prepare_path "${boot_file_unpack_name}" 0)
        # check whether boot_file_unpack_name exist - if not then run unpack cmd
        if [[ ! -f "${boot_file_unpack_name}" ]]; then
            # prepare and run unpack cmd
            boot_file_unpack_cmd=$(prepare_path "${boot_file_unpack_cmd}" 0)
            log_info "${boot_file_unpack_cmd}"
            eval "${boot_file_unpack_cmd}"
        fi
        local boot_file_src_file="${boot_file_unpack_name}"
    fi

    # process convert from raw
    if [[ $boot_file_convert_from_raw -eq 1 ]]; then
        VBoxManage convertfromraw "${boot_file_src_file}" "${boot_file}" --format "${disk_format}"
        if [[ $keep_boot_src_file -eq 0 ]]; then
            rm -f "${boot_file_src_file}"
        fi
    else
        # check whether full path to boot_file_src_file is same as boot_file and boot_file was already created
        if [[ -f "${boot_file}" ]]; then
            return
        fi
        # check whether cp or mv; mv mean don't keep boot_file_src_file; keep only boot_file
        if [[ $keep_boot_src_file -eq 0 ]]; then
            mv -f "${boot_file_src_file}" "${boot_file}"
        else
            cp "${boot_file_src_file}" "${boot_file}"
        fi
    fi
}

# Prepare ssh keys
get_priv_ssh_key() {
    # check whether keys dir exist
    if [[ ! -d "${ssh_keys_path}" ]]; then
        log_info "Creates vbkick ssh keys directory"
        mkdir "${ssh_keys_path}"
    fi
    # check whether private key exist
    if [[ ! -f "${ssh_keys_path}/${ssh_priv_key}" ]]; then
        curl_safe "${ssh_priv_key_src}" "${ssh_keys_path}/${ssh_priv_key}"
    fi
    # change ssh key permissions - too open private key will be ignored
    chmod 600 "${ssh_keys_path}/${ssh_priv_key}"
}

build_vm() {
    # check whether VM already exist
    if is_present; then
        log_error "${VM} already exist"
        exit 1
    fi
    # load vm description/definition
    load_definition
    # get ssh private key
    if [[ $ssh_keys_enabled -eq 1 ]]; then
        get_priv_ssh_key
    fi
    # check SSH port usage
    check_port_usage $ssh_host_port "SSH host"
    # start simple webserver (in background)
    start_web_server
    # download boot/iso files
    download_boot_media
    download_guest_additions_media
    # create VM box with given settings
    create_box
    # host ip to connect from guest
    local host_ip=10.0.2.2
    # start VM
    if [[ $gui_enabled -eq 1 ]]; then
        VBoxManage startvm --type gui "${VM}"  && sleep $boot_wait
    else
        VBoxManage startvm --type headless "${VM}" && sleep $boot_wait
    fi
    # boot VM machine
    log_info "Sending keyboard scancodes:"
    for boot_cmd in "${boot_cmd_sequence[@]}"; do
        if [[ -z "${boot_cmd}" ]]; then
            continue
        fi
        boot_cmd=${boot_cmd//%IP%/$host_ip}
        boot_cmd=${boot_cmd//%PORT%/$kickstart_port}
        boot_cmd=${boot_cmd//%NAME%/${VM}}
        log_info "${boot_cmd}"
        # converts string to scancode via external python script
        local boot_cmd_code=$(printf "${boot_cmd}" | convert_2_scancode.py)
        # sends code to VM
        for code in $boot_cmd_code; do
            if [[ "${code}" == "wait" ]]; then
                sleep 1
            else
                VBoxManage controlvm "${VM}" keyboardputscancode $code
                sleep 0.02
            fi
        done
        sleep $boot_seq_wait
    done

    # wait until machine will be ready (ssh connection start working) or timeout was reached
    kickstart_monitoring

    # stop webserver
    stop_web_server

    exit 0
}

create_box() {
    # Register vm
    VBoxManage createvm --name "${VM}" --ostype "${os_type_id}" --register

    # Creates disks
    # Get default location for disks
    local location=$(VBoxManage list  systemproperties | grep "Default machine folder" | cut -d':' -f 2 | sed 's/^ *//g')

    # SATA controller - place for hdd and iso files
    # SATA controller allow add 30 disks, but vbkick reserve port 0 for boot media and port 1 for guest additions
    # check disk_size lenght
    if [[ ${#disk_size[@]} -gt 28 ]]; then
        log_error "Too many disks in disk_size (limited to 28 disks)"
        return 1;
    fi
    if [[ "${vb_version}" > "4.3.0" ]] || [[ "${vb_version}" == "4.3.0" ]]; then
        VBoxManage storagectl "${VM}" --name "SATA Controller"\
        --add sata --hostiocache $hostiocache --portcount $((${#disk_size[@]}+2))
    else
        VBoxManage storagectl "${VM}" --name "SATA Controller"\
        --add sata --hostiocache $hostiocache --sataportcount $((${#disk_size[@]}+2))
    fi
    # SATA controller - add boot media
    VBoxManage storageattach "${VM}" --storagectl "SATA Controller"\
    --type "${boot_file_type}" --port 0 --device 0 --medium "${boot_file}"
    # SATA controller - create and add hdd disks
    local port_nr=2
    for disk in "${disk_size[@]}"; do
        if [[ -z "${disk}" ]]; then
            continue
        fi
        VBoxManage createhd --filename "${location}/${VM}/${VM}-${port_nr}.${disk_format}"\
        --size $disk --format "${disk_format}" --variant Standard
        VBoxManage storageattach "${VM}" --storagectl "SATA Controller"\
        --port $port_nr --device 0 --type hdd --medium "${location}/${VM}/${VM}-${port_nr}.${disk_format}"
        local port_nr=$((port_nr+1))
    done
    # SATA controller - add VBoxGuestAdditions iso
    if [[ $guest_additions_attach -eq 1 ]]; then
        if [[ ! -z "${guest_additions_path}" ]]; then
            # custom VBoxGuestAdditions
            VBoxManage storageattach "${VM}" --storagectl "SATA Controller"\
            --type dvddrive --port 1 --device 0 --medium "${guest_additions_path}/VBoxGuestAdditions_${vb_version}.iso"
        else
            # default VBoxGuestAdditions
            VBoxManage storageattach "${VM}" --storagectl "SATA Controller"\
            --type dvddrive --port 1 --device 0 --medium emptydrive
            VBoxManage storageattach "${VM}" --storagectl "SATA Controller"\
            --type dvddrive --port 1 --device 0 --medium additions
        fi
    fi

    # Tuning VM
    # setting cpu's
    VBoxManage modifyvm "${VM}" --cpus $cpu_count
    # setting memory size
    VBoxManage modifyvm "${VM}" --memory $memory_size
    # setting video memory size
    VBoxManage modifyvm "${VM}" --vram $video_memory_size
    # setting bootorder
    VBoxManage modifyvm "${VM}" --boot1 disk --boot2 dvd --boot3 none --boot4 none
    # setting networking
    VBoxManage modifyvm "${VM}" --nic1 nat --nictype1 $nic_type --cableconnected1 on
    # other settings
    for option in "${vm_options[@]}"; do
        if [[ -z "${option}" ]]; then
            continue
        fi
        local key="${option%%:*}"
        local value="${option##*:}"
        VBoxManage modifyvm "${VM}" --"${key}" "${value}"
    done
    # set extradata
    for extradata in "${vm_extradata[@]}"; do
        if [[ -z "${extradata}" ]]; then
            continue
        fi
        local key="${extradata%%:*}"
        local value="${extradata##*:}"
        VBoxManage setextradata "${VM}" "${key}" "${value}"
    done

    # ssh port NAT mapping; ssh port is a special one
    if ! is_port_present "${ssh_port_name}"; then
        VBoxManage controlvm "${VM}" natpf1 "${ssh_port_name},tcp,,${ssh_host_port},,${ssh_guest_port}"
    fi

    # extra ports NAT mapping
    add_extra_ports_mapping

    # add shared folders
    add_shared_folders
}

add_extra_ports_mapping() {
    for port in "${extra_ports[@]}"; do
        if [[ -z "${port}" ]]; then
            continue
        fi

        OIFS=$IFS
        IFS=':'
        local port_info=($port)
        if [[ ${#port_info[@]} -ne 3 ]]; then
            log_error "one of the ports in extra_ports has invalid format."
            IFS=$OIFS
            return 1
        fi
        local port_name="${port_info[0]}"
        local port_host="${port_info[1]}"
        local port_guest="${port_info[2]}"
        # add only if port doesn't exist
        if ! is_port_present "${port_name}"; then
            VBoxManage controlvm "${VM}" natpf1 "${port_name},tcp,,${port_host},,${port_guest}"
        fi
        IFS=$OIFS
    done
}

remove_extra_ports_mapping() {
    for port in "${extra_ports[@]}"; do
        if [[ -z "${port}" ]]; then
            # note which extra ports were removed by moving extraports_removed_ptr
            extraports_removed_ptr=$((extraports_removed_ptr+1))
            continue
        fi
        local port_name=${port%%:*}
        if is_port_present "${port_name}"; then
            VBoxManage modifyvm "${VM}" --natpf1 delete "${port_name}"
            # note which extra ports were removed by moving extraports_removed_ptr
            extraports_removed_ptr=$((extraports_removed_ptr+1))
        fi
    done
}

add_shared_folders() {
    for folder in "${shared_folders[@]}"; do
        if [[ -z "${folder}" ]]; then
            continue
        fi

        OIFS=$IFS
        IFS=':'
        local folder_info=($folder)
        if [[ ${#folder_info[@]} -lt 2 ]]; then
            log_error "one of the folders in shared_folders has no info about path."
            IFS=$OIFS
            return 1
        fi
        local folder_name="${folder_info[0]}"
        local folder_path=$(prepare_path "${folder_info[1]}" 1)

        # check whether shared_folder already exist
        if is_shared_folder_present "${folder_name}"; then
            IFS=$OIFS
            continue
        fi

        if [[ ${#folder_info[@]} -eq 2 ]]; then
            log_info "VBoxManage sharedfolder add  \"${VM}\" --name \"${folder_name}\" --hostpath \"${folder_path}\""
            VBoxManage sharedfolder add "${VM}" --name "${folder_name}" --hostpath "${folder_path}"
        elif [[ ${#folder_info[@]} -eq 3 ]]; then
            log_info "VBoxManage sharedfolder add  \"${VM}\" --name \"${folder_name}\" --hostpath \"${folder_path}\" --${folder_info[2]}"
            VBoxManage sharedfolder add "${VM}" --name "${folder_name}" --hostpath "${folder_path}" --"${folder_info[2]}"
        elif [[ ${#folder_info[@]} -eq 4 ]]; then
            log_info "VBoxManage sharedfolder add  \"${VM}\" --name \"${folder_name}\" --hostpath \"${folder_path}\" --${folder_info[2]} --${folder_info[3]}"
            VBoxManage sharedfolder add "${VM}" --name "${folder_name}" --hostpath "${folder_path}" --"${folder_info[2]}" --"${folder_info[3]}"
        else
            log_error "too much options in one of the shared_folders."
            IFS=$OIFS
            return 1
        fi
        IFS=$OIFS
    done
}

remove_shared_folders() {
    for folder in "${shared_folders[@]}"; do
        if [[ -z "${folder}" ]]; then
            # note which shared folders were removed by moving sharedfolders_removed_ptr
            sharedfolders_removed_ptr=$((sharedfolders_removed_ptr+1))
            continue
        fi
        local folder_name=${folder%%:*}
        if is_shared_folder_present "${folder_name}"; then
            VBoxManage sharedfolder remove "${VM}" --name "${folder_name}"
            # note which shared folders were removed by moving sharedfolders_removed_ptr
            sharedfolders_removed_ptr=$((sharedfolders_removed_ptr+1))
        fi
    done
}

# Check whether machine was kickstarted before timeout
kickstart_monitoring() {
    local kickstart_counter=0
    local extra_ssh_options="-o ConnectionAttempts=1 -o ConnectTimeout=1"
    # ssh key authentication enabled
    if [[ $ssh_keys_enabled -eq 1 ]]; then
        # create path to ssh private key
        local key_path="${ssh_keys_path}/${ssh_priv_key}"
        printf "\n"
        log_info "Waiting for ssh login with user ${ssh_user} to 127.0.0.1:${ssh_host_port} to work, kickstart_timeout=${kickstart_timeout} sec"
        # wait until ssh start working (communication chanel with VM) or kickstart_timeout was reached
        while ! ssh "${ssh_user}@127.0.0.1" -q -t -i ${key_path} -p $ssh_host_port $ssh_options $extra_ssh_options -C "echo"\
            && [[ $kickstart_counter -le $kickstart_timeout ]]; do
            kickstart_counter=$((kickstart_counter+1))
            printf "."
            sleep 1
        done
        printf "\n"
    else
        # if no ssh key authentication enabled then wait until timeout will be reached
        log_info "Sleeping ${kickstart_timeout} seconds ..."
        sleep $kickstart_timeout
    fi
}

destroy_vm() {
    # check whether VM already exist
    if ! is_present; then
        log_error "${VM} doesn't exist"
        exit 1
    fi

    # destroy VM
    log_info "Destroy ${VM}"
    read -r -p "Are you sure? [y/N]" ans
    if [[ ! $ans =~ ^[Yy]$ ]]; then
        exit 1
    fi

    # check whether VM is running
    if is_running; then
        log_info "Poweroff ${VM}"
        VBoxManage controlvm "${VM}" poweroff
        sleep 1
    fi

    log_info "Destroying..."
    VBoxManage unregistervm "${VM}" --delete
    exit 0
}

export_vm() {
    #
    # basic replacement for that vagrant command:
    # vagrant package --base "${VM}" --output "${VM}.box"
    # if more customisation required use: vagrant package (--help)
    #
    # tar command is required, check whether is installed
    depend_check "tar" "tar"
    # load vm description/definition
    load_definition
    # check whether VM_NAME.box exist in current dir
    if [[ -f "${VM}.box" ]]; then
        log_error "${VM}.box already exist in `pwd`"
        exit 1
    fi
    # check whether VM exist
    if ! is_present; then
        log_error "${VM} doesn't exist"
        exit 1
    fi
    # check whether VM is running and shutdown it
    shutdown

    # clearing previously set port forwarding rules (only if exist)
    if is_port_present "${ssh_port_name}"; then
        VBoxManage modifyvm "${VM}" --natpf1 delete "${ssh_port_name}"
        ssh_natmapping_was_removed=1
    fi

    # rm extra ports (only if exist)
    remove_extra_ports_mapping

    # rm shared folder (only if exist)
    remove_shared_folders

    # create tmp_dir for export data
    tmp_dir=$(TMPDIR=. mktemp -d)
    # export VM to tmp_dir
    VBoxManage export "${VM}" --output "${tmp_dir}/box.ovf"
    # get VM MAC Address
    local mac_address=$(VBoxManage showvminfo --details --machinereadable "${VM}"\
    | grep macaddress1 | cut -d"=" -f 2)
    # add Vagrantfile
    printf "Vagrant.configure(\"2\") do |config|
    \t# This Vagrantfile is auto-generated by \`vagrant package\` to contain
    \t# the MAC address of the box. Custom configuration should be placed in
    \t# the actual \`Vagrantfile\` in this box.
    \tconfig.vm.base_mac = ${mac_address}
    end\n
    # Load include vagrant file if it exists after the auto-generated
    # so it can override any of the settings
    include_vagrantfile = File.expand_path(\"../include/_Vagrantfile\", __FILE__)
    load include_vagrantfile if File.exist?(include_vagrantfile)\n" > "${tmp_dir}/Vagrantfile"
    # add metadata.json
    printf "{\"provider\":\"virtualbox\"}\n" > "${tmp_dir}/metadata.json"
    # create VM_NAME.box (gzip) file
    cd $tmp_dir
    tar -cvzf "${VM}.box" *
    cd ..
    mv "${tmp_dir}/${VM}.box" .
    # remove tmp_dir
    rm -rf $tmp_dir
    # help recover some changes made on VM during exporting
    recover_vm_state
    log_info "Done: `pwd`/${VM}.box"
    exit 0
}

recover_vm_state() {
    # add NAT mapping after exporting - only if exist prev.
    if [[ $ssh_natmapping_was_removed -eq 1 ]]; then
        VBoxManage controlvm "${VM}" natpf1 "${ssh_port_name},tcp,,${ssh_host_port},,${ssh_guest_port}"
        ssh_natmapping_was_removed=0
    fi
    # add extra ports after exporting - only if exist prev.
    if [[ $extraports_removed_ptr -gt 0 ]]; then
        # add only folders which were removed, skip others (useful when SIGINT)
        extra_ports=("${extra_ports[@]:0:$extraports_removed_ptr}")
        add_extra_ports_mapping
        extraports_removed_ptr=0
    fi
    # add shared folder after exporting - only if exist prev.
    if [[ $sharedfolders_removed_ptr -gt 0 ]]; then
        # add only folders which were removed, skip others (useful when SIGINT)
        shared_folders=("${shared_folders[@]:0:$sharedfolders_removed_ptr}")
        add_shared_folders
        sharedfolders_removed_ptr=0
    fi
}

turn_on() {
    # check whether VM is already running
    if is_running; then
        # nothing to do
        log_ginfo "${VM} is already running..."
        exit 0
    fi

    # check whether VM already exist
    if ! is_present; then
        log_error "${VM} doese not exist. Use \"vbkick build\" to create the new VM."
        exit 1
    fi

    if [[ $gui_enabled -eq 1 ]]; then
        VBoxManage startvm --type gui "${VM}"
    else
        VBoxManage startvm --type headless "${VM}"
    fi
}

turn_off() {
    # check whether VM is running
    if ! is_running; then
        log_ginfo "${VM} is already turn off."
        exit 0
    fi

    # load vm description/definition
    load_definition

    #exec shutdown
    shutdown
}

shutdown() {
    # check whether VM is running and exec shutdown_cmd via SSH
    if is_running; then
        log_info "Shutting down ${VM}."
        if [[ $ssh_keys_enabled -eq 1 ]]; then
            # ssh key authentication enabled
            # if key not exist then get it
            get_priv_ssh_key
            # create path to ssh private key
            local key_path="${ssh_keys_path}/${ssh_priv_key}"
            ssh "${ssh_user}@127.0.0.1" -q -t -i ${key_path} -p $ssh_host_port $ssh_options -C "${shutdown_cmd}" || true
        else
            auto_passwd_ssh "${shutdown_cmd}"
        fi
        # wait until VM is down or shutdown_timeout was reached
        local shutdown_counter=0
        while is_running && [[ $shutdown_counter -le $shutdown_timeout ]]; do
            shutdown_counter=$((shutdown_counter+1))
            printf "."
            sleep 1
        done
    fi
    printf "\n"

    # check whether VM is still running, if so use acpipowerbutton
    if is_running; then
        VBoxManage controlvm "${VM}" acpipowerbutton
        log_info "${VM} - acpipowerbutton was used. Waiting $shutdown_timeout seconds..."
        sleep $shutdown_timeout
    else
        log_info "${VM} was shutdown cleanly."
        sleep 3
        return
    fi

    # check whether VM is still running, if so poweroff it using hard way.
    if is_running; then
        VBoxManage controlvm "${VM}" poweroff
        log_info "${VM} was powered off."
        sleep 3
    else
        log_info "${VM} was shutdown cleanly."
        sleep 3
    fi
}

update_guest_additions_media() {
    # check whether VM exist
    if ! is_present; then
        log_error "${VM} doese not exist. Use \"vbkick build\" to create the new VM."
        return 1
    fi
    # get current guest version
    if VBoxManage guestproperty enumerate "${VM}" | grep -q "GuestAdd/Version"; then
        # guest already exist, get current version
        local guest_version=$(VBoxManage guestproperty get "${VM}" "/VirtualBox/GuestAdd/Version" | cut -f 2 -d " ")
    else
        # guest doesn't exist
        local guest_version=""
    fi

    # check whether we need update or install VBoxGuestAdditions
    if [[ "${vb_version}" == "${guest_version}" ]]; then
        log_ginfo "VBoxGuestAdditions on ${VM} is up-to-date - update media iso is not needed."
        return
    fi
    # TODO [LOW]: use Storage Controller Name (1) and type to find controller name
    # check whether "SATA Controller (1, 0)" exist - require to attach iso and creates /dev/sr1 or /dev/sr0
    if ! VBoxManage showvminfo "${VM}" | grep -qw "SATA Controller (1, 0)"; then
        log_error "\"SATA Controller (1, 0)\" for \"${VM}\" doesn't exist."
        log_error "\"SATA Controller\" is sata controller name used by vbkick."
        log_error "More: 'VBoxManage showvminfo \"${VM}\" | grep -w \"Controller\"'\n"
        log_error "To create proper controller use:"
        log_error "'VBoxManage storagectl \"${VM}\" --name \"SATA Controller\" --add sata --hostiocache $hostiocache --portcount $((${#disk_size[@]}+2))'"
        log_error "'VBoxManage storageattach \"${VM}\" --storagectl \"SATA Controller\" --type dvddrive --port 1 --device 0 --medium emptydrive'\n"
        log_error "To do this \"${VM}\" must be shutdown !!!"
        log_error "Remember - VM Guest may have only one sata controller."
        return 1
    fi
    # Attach new VBoxGuestAdditions to install
    # vbkick creates VM with SATA Controller port 1 available for VBoxGuestAdditions iso.
    if [[ ! -z "${guest_additions_path}" ]]; then
        # custom VBoxGuestAdditions
        download_guest_additions_media
        VBoxManage storageattach "${VM}" --storagectl "SATA Controller"\
        --type dvddrive --port 1 --device 0 --medium "${guest_additions_path}/VBoxGuestAdditions_${vb_version}.iso" --forceunmount
    else
        # default VBoxGuestAdditions
        VBoxManage storageattach "${VM}" --storagectl "SATA Controller"\
        --type dvddrive --port 1 --device 0 --medium additions --forceunmount
    fi
    # Note: Guest OS (Linux) does not support automatic Guest Additions updating:
    # VBoxManage guestcontrol <vmname>|<uuid> updateadditions
    # Manuall Guest Additions update/installation is required (via lazy_update cmd).
}

validate_vm() {
    #
    # test should be smart enough to check what I really want to test
    # e.g. If I don't need chef, don't test whether I have chef
    #
    # load vm description/definition
    load_definition
    # exec scripts on VM Guest via ssh
    if ! ssh_exec ${#validate_transport[@]} "${validate_transport[@]}" "${validate_launch[@]}"; then
        exit 1
    fi
    exit 0
}

lazy_postinstall() {
    # load vm description/definition
    load_definition
    # exec scripts on VM Guest via ssh
    if ! ssh_exec ${#postinstall_transport[@]} "${postinstall_transport[@]}" "${postinstall_launch[@]}"; then
        exit 1
    fi
    exit 0
}

lazy_update() {
    # load vm description/definition
    load_definition
    # Check whether VBoxGuestAdditions should be installed. If not then not update additions.
    if [[ $guest_additions_attach -eq 1 ]]; then
        if ! update_guest_additions_media; then
            exit 1
        fi
    fi
    # Run other update scripts on VM Guest via ssh
    if ! ssh_exec ${#update_transport[@]} "${update_transport[@]}" "${update_launch[@]}"; then
        exit 1
    fi
    exit 0
}

ssh_exec() {
    #
    # transport scripts to VM Guest via SCP and exec them via SSH
    #
    # get number of transport files/directories; transport array length
    local pos=$1
    shift
    # get transport array; everything to $pos
    local transport=("${@:1:$pos}")
    shift $pos
    # get launch array;
    local launch=("${@}")

    # check whether VM is running
    if ! is_running; then
        log_error "${VM} is not running..."
        return 1
    fi

    # checking port forwarding (if no proper rules, try add new one for NAT mapping)
    if ! VBoxManage showvminfo "${VM}" | grep "NIC 1" | grep "host port = ${ssh_host_port}"\
        | grep -q "guest port = ${ssh_guest_port}"; then
        log_info "NAT mapping - enable ssh port forwarding"
        VBoxManage controlvm "${VM}" natpf1 "${ssh_port_name},tcp,,${ssh_host_port},,${ssh_guest_port}"
    fi

    # ssh key authentication enabled
    if [[ $ssh_keys_enabled -eq 1 ]]; then
        # if key not exist then get it
        get_priv_ssh_key
    fi

    # check whether all pkt can by transported, before starting transporting -
    # - be a bit more atomic
    for pkt in "${transport[@]}"; do
        if [[ -z "${pkt}" ]] || [[ -d "${pkt}" ]] || [[ -f "${pkt}" ]]; then
            continue
        else
            # pkt is neither file nor directory
            log_error "${pkt} is neither file nor directory"
            return 1
        fi
    done

    if ! ssh_do_transport "${transport[@]}"; then
        ssh_do_cleanup "${transport[@]}"
        return 1
    fi
    ssh_do_launch "${launch[@]}"
    ssh_do_cleanup "${transport[@]}"
}

ssh_do_transport() {
    local transport=("${@}")
    # transport scripts to guest
    for pkt in "${transport[@]}"; do
        if [[ -z "${pkt}" ]]; then
            continue
        fi
        log_info "Scp: ${pkt}"
        # check whether pkt is file or dir
        if [[ -d "${pkt}" ]]; then
            # pkt is directory
            if [[ $ssh_keys_enabled -eq 1 ]]; then
                # create path to ssh private key
                local key_path="${ssh_keys_path}/${ssh_priv_key}"
                scp -q -P $ssh_host_port -i "${key_path}" $ssh_options -r "${pkt}" "${ssh_user}@127.0.0.1:~${ssh_user}"
            else
                # 1 mean scp directory (recursive)
                auto_passwd_scp "${pkt}" 1
            fi
        elif [[ -f "${pkt}" ]]; then
            # pkt is file
            if [[ $ssh_keys_enabled -eq 1 ]]; then
                # create path to ssh private key
                local key_path="${ssh_keys_path}/${ssh_priv_key}"
                scp -q -P $ssh_host_port -i "${key_path}" $ssh_options "${pkt}" "${ssh_user}@127.0.0.1:~${ssh_user}"
            else
                # 0 mean scp file
                auto_passwd_scp "${pkt}" 0
            fi
        fi
        sleep 1
    done
}

ssh_do_launch() {
    local launch=("${@}")
    # run commands via ssh
    for cmd in "${launch[@]}"; do
        if [[ -z "${cmd}" ]]; then
            continue
        fi
        # %HOST% tag - check whether command should be executed on host (not guest)
        if [[ "${cmd}" =~ ^\ *%HOST% ]]; then
            # extract command
            cmd=${cmd//%HOST%/}
            # process defined/template variables
            cmd=$(prepare_path "${cmd}" 0)
            log_info "Exec (on host): ${cmd}"
            eval "${cmd}"
            continue
        fi
        log_info "Exec: ${cmd}"
        if [[ $ssh_keys_enabled -eq 1 ]]; then
            # create path to ssh private key
            local key_path="${ssh_keys_path}/${ssh_priv_key}"
            ssh -q "${ssh_user}@127.0.0.1" -t -i ${key_path} -p $ssh_host_port $ssh_options -C "${cmd}"
        else
            auto_passwd_ssh "${cmd}"
        fi
        sleep 1
    done
}

ssh_do_cleanup() {
    local transport=("${@}")
    # clean after scp by rm transported media/scripts
    if [[ $clean_transported -eq 1 ]]; then
        for pkt in "${transport[@]}"; do
            if [[ -z "${pkt}" ]]; then
                continue
            fi
            log_info "Clean transported: ${pkt}"
            local pkt_to_clean=$(basename "${pkt}")
            if [[ $ssh_keys_enabled -eq 1 ]]; then
                # create path to ssh private key
                local key_path="${ssh_keys_path}/${ssh_priv_key}"
                ssh -q "${ssh_user}@127.0.0.1" -t -i ${key_path} -p $ssh_host_port $ssh_options -C "cd ~${ssh_user} && rm -rf ${pkt_to_clean}"
            else
                auto_passwd_ssh "cd ~${ssh_user} && rm -rf ${pkt_to_clean}"
            fi
            sleep 1
        done
    fi
}

lazy_ssh() {
    # check whether VM is running
    if ! is_running; then
        log_error "${VM} is not running..."
        exit 1
    fi
    # load vm description/definition
    load_definition
    if [[ $ssh_keys_enabled -eq 1 ]]; then
        # if key not exist then get it
        get_priv_ssh_key
        # create path to ssh private key
        local key_path="${ssh_keys_path}/${ssh_priv_key}"
        ssh -q "${ssh_user}@127.0.0.1" -t -i ${key_path} -p $ssh_host_port $ssh_options
    else
        auto_passwd_ssh ""
    fi
}

auto_passwd_ssh() {
    local _cmd="${1}"
    if command -v expect >/dev/null 2>&1; then
        if [[ -z "${_cmd}" ]]; then
            # No cmd to exec, interactive shell
            local _expect_cmd="ssh -q \"${ssh_user}@127.0.0.1\" -t -p $ssh_host_port $ssh_options"
        else
            local _expect_cmd="ssh -q \"${ssh_user}@127.0.0.1\" -t -p $ssh_host_port $ssh_options -C \"${_cmd}\""
        fi
        expect -c "log_user 0; spawn $_expect_cmd; expect password; send \"$ssh_password\r\"; interact; catch wait reason; exit [lindex \$reason 3]"
    else
        log_warning "'expect' command not exist - install 'expect (tcl)' to automate ssh authentication without ssh_key."
        log_warning "To use ssh_key authentication setup ssh_keys_enabled=1 in your ${definition_fname}"
        # Process without expect
        if [[ -z "$_cmd" ]]; then
            # No cmd to exec, interactive shell
            ssh -q "${ssh_user}@127.0.0.1" -t -p $ssh_host_port $ssh_options
        else
            ssh -q "${ssh_user}@127.0.0.1" -t -p $ssh_host_port $ssh_options -C "${cmd}"
        fi
    fi
}

auto_passwd_scp() {
    local _src="${1}"
    local _recursive="${2}"
    if command -v expect >/dev/null 2>&1; then
        if [[ $_recursive -eq 1 ]]; then
            local _expect_cmd="scp -q -P $ssh_host_port $ssh_options -r \"${_src}\" \"${ssh_user}@127.0.0.1:~${ssh_user}\""
        else
            local _expect_cmd="scp -q -P $ssh_host_port $ssh_options \"${_src}\" \"${ssh_user}@127.0.0.1:~${ssh_user}\""
        fi
        expect -c "log_user 0; spawn $_expect_cmd; expect password; send \"$ssh_password\r\"; expect eof; catch wait reason; exit [lindex \$reason 3]"
    else
        log_warning "'expect' command not exist - install 'expect (tcl)' to automate ssh authentication without ssh_key."
        log_warning "To use ssh_key authentication setup ssh_keys_enabled=1 in your ${definition_fname}"
        # Process without expect
        if [[ $_recursive -eq 1 ]]; then
            scp -q -P $ssh_host_port $ssh_options -r "${_src}" "${ssh_user}@127.0.0.1:~${ssh_user}"
        else
            scp -q -P $ssh_host_port $ssh_options "${_src}" "${ssh_user}@127.0.0.1:~${ssh_user}"
        fi
    fi
}

start_web_server() {
    # Do not start webserver - remote server is used instead to serve kickstart files.
    if [[ $webserver_disabled -eq 1 ]]; then
        return
    fi
    # check whether port is not used by other proc
    check_port_usage $kickstart_port "kickstart"
    # start simple webserver serving files in background
    py_version=$(python -V 2>&1 | cut -d' ' -f 2 | cut -d'.' -f 1)
    if [[ $py_version -eq 2 ]]; then
        webserver_module="SimpleHTTPServer"
    elif [[ $py_version -eq 3 ]]; then
        webserver_module="http.server"
    else
        log_error "Unknown python version."
        return 1
    fi
    python -m $webserver_module $kickstart_port &
    # get the pid already spawned process, to kill it later
    web_pid=$!
    # update webserver_status variable
    webserver_status=1
    sleep 2
    # check whether web server was really started
    if ! is_port_used $kickstart_port; then
        log_error "webserver was not started"
        if kill -s 0 $web_pid 2>/dev/null; then
            kill $web_pid
        fi
        webserver_status=0
        return 1
    fi
    log_info "webserver has been started (pid $web_pid)"
}

stop_web_server() {
    # check whether webserver is running
    if [[ $webserver_status -eq 0 ]]; then
        return
    fi
    log_info "Stopping webserver (pid $web_pid)"
    # with "set -e -E" if kill command fail then ERR trap is processing
    # simply execution of function is not continued
    webserver_kill_cmd_status=1
    # check whether process exist and accept signals before sending SIGTERM
    if kill -s 0 $web_pid 2>/dev/null; then
        kill $web_pid
    fi
    webserver_kill_cmd_status=0
    # update webserver_status variable
    webserver_status=0
    # kill command is sucessfull when SIGTERM is sent to running process
    # not when child process was really killed
    if ! ps -ef | grep "python -m $webserver_module $kickstart_port" | grep -qv grep; then
        log_info "webserver was stopped"
    else
        log_warning "problem with stopping webserver. Kill process manually"
        ps -ef | grep "python -m $webserver_module $kickstart_port" | grep -v grep
    fi
}

# (signals and error handler) - cleaning after ctr-c, etc.
clean_up() {
    log_info "Signal/Error handler - cleanup before exiting..."
    if [[ $webserver_kill_cmd_status -eq 0 ]]; then
        # stop webserver (only if stop_web_server function didn't fail previuosly)
        stop_web_server
    else
        # previuosly executed stop_web_server function fail in killing $web_pid
        log_warning "problem with killing webserver (proc ${web_pid}). Kill process manually."
    fi
    # help recover some changes made on VM during exporting
    recover_vm_state
    # clean tmp_dir if exist
    if [[ -d $tmp_dir ]]; then
        rm -rf $tmp_dir
    fi
    exit 1
}

main() {
    # 2 Args required, 3rd is optional - ACTION VM_NAME (DEFINITION_FILE_NAME)
    args_num=$#
    if [[ $args_num -lt 2 ]] || [[ $args_num -gt 3 ]]; then
        usage
        exit 1
    fi
    if [[ $args_num -eq 3 ]]; then
        definition_fname="${3}"
    fi

    # check whether we have everything to start with vbkick
    dependencies_check
    vb_version=$(get_vb_version)

    process_args "${1}" "${2}"
}

## MAIN ##
# signals and errors handler
# Note: no exit handler is set, so `exit 1` ends the program without running clean_up,
# this is done on purpose to not run clean_up twice when error occur
trap clean_up SIGHUP SIGINT SIGTERM ERR
main "$@"
