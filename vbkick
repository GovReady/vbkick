#!/bin/bash

# The MIT License
#
# Copyright (c) 2013, Kamil Wilas (wilas.pl)
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

# Help build Virtualbox guest VMs and Vagrant base boxes

# Secure bash
# More about options: http://wiki.bash-hackers.org/commands/builtin/set
# treat unset variables as an error
set -u;
# exit when cmd fail (use ERR trap for clean exit)
set -e; set -E;
# fail the entire pipeline if any part of it fails
set -o pipefail;
# debug mode
#set -x;
# http://mywiki.wooledge.org/glob
shopt -s failglob;
# enable POSIX mode
# http://www.gnu.org/software/bash/manual/html_node/Bash-POSIX-Mode.html
set -o posix    

# VM default settings - basic
hostiocache="on"
cpu_count=1
memory_size=512
disk_size=(10140)
disk_format="vdi"
video_memory_size=10
# list of VM options: ("option1:value" "option2:value")
vm_options=("ioapic:on")
# list of VM extradata to set: ("extradata:value" "extradata:value")
vm_extradata=("")
# by default gui enabled unless the VirtualBox GUI is missing
gui_enabled=1
if ! command -v VirtualBox >/dev/null 2>&1; then
    gui_enabled=0
fi
# by default add one shared folder - to disable: shared_folders=("")
shared_folders=("vbkick:%PWD%:automount")
# by default no extra ports is mapping
extra_ports=("")

# Guest Additions default settings
# set to 0 to not attach VBoxGuestAdditions iso to guest
guest_additions_attach=1
# path where guest_additions should be download, if empty then not download custom VBoxGuestAdditions to host, use default one
guest_additions_path=""

# Boot default settings
#boot_file -> required option, fail if not in definition
#boot_file_src -> required option, fail if not in definition
# type of boot media e.g.: hdd, dvddrive; by default dvddrive
boot_file_type="dvddrive"
# default path for src media needed to create destination boot_file
boot_file_src_path="iso"
# by default checksum is empty
# WARNING is given during processing if checksum is wrong
boot_file_src_checksum=""
# default cheksum type is sha256
boot_file_checksum_type="sha256"
# by default unpacke is not needed
boot_file_unpack_cmd=""
# where is the path and the filename after unpack
boot_file_unpack_name=""
# is boot_file_src raw image and need to be converted
boot_file_convert_from_raw=0
# whether use cp or mv when boot_file is created form boot_file_src_file; 
# mv mean don't keep boot_file_src_file; keep only boot_file; by default 0 - use mv
keep_boot_src_file=0
# default time before boot_cmd_sequence start
boot_wait=10
# list of boot_cmd: ("cmd1" "cmd2" "cmd3")
boot_cmd_sequence=("")
# default number of second wait between each boot_cmd
boot_seq_wait=1
# default webserver port to serve kickstart files
kickstart_port=7122
# default max webserver live time
kickstart_timeout=7200
# do not start local webserver, by default 0 - mean start webserver to serve files from current dir.
webserver_disabled=0

# SSH default settings (veeded to run vbkick validate and/or lazy_posinstall)
# by default use ssh keys
ssh_keys_enabled=1
# default user
ssh_user="vbkick"
# default user password - not use when ssh_keys authentication is enabled
ssh_password="vbkick"
# default path to ssh keys
ssh_keys_path="keys"
# default private key name
ssh_priv_key="vbkick_key"
# default auto-download path 
ssh_priv_key_src="https://raw.github.com/wilas/vbkick/master/keys/vbkick_key"
# default ssh host port
ssh_host_port=2222
# default (22) ssh guest port to forwarding
ssh_guest_port=22
# default "vbkickSSH"
ssh_port_name="vbkickSSH"
# default extra ssh and scp options
# UserKnownHostsFile - database file to use for storing the user host keys
# StrictHostKeyChecking - if "no" then automatically add new host keys to the host key database file
# you may consider editing ssh config: http://superuser.com/questions/141344/ssh-dont-add-hostkey-to-known-hosts
ssh_options="-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o NumberOfPasswordPrompts=1"

# Lazy Postinstall default settings
# list of files and directories to transport to guest
postinstall_transport=("")
# list of postinstall commands
postinstall_launch=("")

# Validate default settings
# list of files and directories to transport to guest
validate_transport=("")
# list of validate commands
validate_launch=("")

# Lazy Update default settings
# list of files and directories to transport to guest
update_transport=("")
# list of update commands
update_launch=("")

# Clean
# list of files to autoupdate VBOX_VERSION value
files_to_autoupdate_vbox_version=("")
# rm or not already transported via SCP files/directories (from postinstall, validate)
clean_transported=0
# nice for OS shutdown command
shutdown_cmd="sudo /sbin/halt -h -p"
# when timeout is reached and VM is still running, hard poweroff is used
shutdown_timeout=20

# Other global variables - do not use it in definition.cfg (will be overwrite during program runtime)
# default definition file
definition_fname="definition.cfg"
# virtual machine name
VM=""
# 0 - webserver is not running or kill isn't able to stop it
webserver_status=0
# 0 - webserver was killed cleanly or we didn't try kill it yet
webserver_kill_cmd_status=0
# during exporting tmp directory is created
tmp_dir=""
# during exporting NAT mapping is removed (temporary) - help recover state before exporting
ssh_natmapping_was_removed=0
# during exporting shared folders are removed (temporary) - help recover state before exporting
sharedfolders_removed_ptr=0
# during exporting extra ports are removed (temporary) - help recover state before exporting
extraports_removed_ptr=0

# For nice printing
GREEN="\e[1;32m"
RED="\e[1;31m"
YELLOW="\e[1;33m"
NORMAL="\e[0m"
function green {
    printf "$GREEN$*$NORMAL"
}
function red {
    printf "$RED$*$NORMAL" >&2
}
function yellow {
    printf "$YELLOW$*$NORMAL"
}

# Display help
function usage {
    printf "Desc: the automatic Virtualbox Guests and Vagrant Base Boxes builder\n"
    printf "\n"
    printf "Usage: $0 ACTION VM_NAME (DEFINITION_FILE_NAME)\n"
    printf "\n"
    printf "Available actions:\n"
    printf "\tbuild                 build VM\n"
    printf "\tpostinstall           run postinstall scripts via ssh\n"
    printf "\tvalidate              run validate/feature scripts via ssh\n"
    printf "\texport                export VM and creates Vagrant VM_NAME.box\n"
    printf "\tupdate                run update scripts via ssh\n"
    printf "\tdestroy               destroy VM\n"
    printf "\tssh                   ssh to VM\n"
    printf "\ton                    turn on VM\n"
    printf "\tshutdown              shutdown VM\n"
    printf "\thelp                  display this help and exit\n"
    printf "\n"
}

# Cmd line parser, take 2 args
function process_args {
    VM="${2}"
    case "$1" in
        "build") build_vm ;;
        "destroy") destroy_vm ;;
        "export") export_vm ;;
        "validate") validate_vm ;;
        "postinstall") lazy_postinstall ;;
        "update") lazy_update ;;
        "ssh") lazy_ssh ;;
        "on") turn_on ;;
        "shutdown") turn_off ;;
        *) usage; exit ;;
    esac
}

# Help automatically update/maintain value of VBOX_VERSION in given files list
function autoupdate_files_with_vbox_version {
    for file in "${files_to_autoupdate_vbox_version[@]}"; do
        # check whether file exist
        if [[ -s "${file}" ]]; then
            # example value to update: VBOX_VERSION="4.2.12", but ignore comments
            sed -r -i "/^#/!s/(VBOX_VERSION)=\"([0-9\.]+)\"/\1=\"$vb_version\"/g" "${file}"
        fi
    done
}

function check_required_options {
    local opts=("boot_file" "boot_file_src" "os_type_id")
    for opt in "${opts[@]}"; do
        if [[ -z "${!opt+x}" ]]; then
            red "Required $opt option is not defined.\n"
            exit 1
        fi
    done
}

# Load definition.cfg config file; it overwrite default settings
function load_definition {
    if [[ -s "${definition_fname}" ]]; then
        # In POSIX mode the '.' and 'source' builtins do not search the current directory
        # for the filename argument if it is not found by searching PATH.
        printf "INFO: Loading \"${definition_fname}\" definition...\n"
        . "./${definition_fname}"
    else 
        red "Not existing or empty \"${definition_fname}\" file in `pwd`\n"
        red "Terminating...\n"
        exit 1
    fi
    check_required_options
    autoupdate_files_with_vbox_version
}

# Get virtualbox version
function get_vb_version {
    local version=$(VBoxManage --version) # e.g. 4.2.12r84980
    local version=${version%r*} #e.g. 4.2.12
    printf "${version}"
}

# Check whether given directory exist
function prepare_path {
    local path="${1}"
    local mkdir_path="${2}"
    # Process special variables in path definition e.g. path="%VBOXFOLDER%/%NAME%"
    local location=$(VBoxManage list  systemproperties | grep "Default machine folder" | cut -d':' -f 2 | sed 's/^ *//g')
    local path=${path//%SRCPATH%/${boot_file_src_path}}
    local path=${path//%VBOXFOLDER%/${location}}
    local path=${path//%PWD%/`pwd`}
    local path=${path//%HOME%/~}
    local path=${path//%NAME%/${VM}}
    # Creates dir if necessary
    if [[ $mkdir_path -eq 1 ]] && [[ ! -z "${path}" ]] && [[ ! -d "${path}" ]]; then
        mkdir -p "${path}"
    fi
    # Return path
    printf "${path}"
}

# Downloads custom VBoxGuestAdditions if required
function download_guest_additions_media {
    if [[ -z "${guest_additions_path}" ]]; then
        # nothing to do
        return
    fi
    guest_additions_path=$(prepare_path "${guest_additions_path}" 1)
    # check whether VBoxGuestAdditions exist
    if [[ ! -f "${guest_additions_path}/VBoxGuestAdditions_${vb_version}.iso" ]]; then
        local additions_url="http://download.virtualbox.org/virtualbox/${vb_version}/VBoxGuestAdditions_${vb_version}.iso"
        curl -Lok "${guest_additions_path}/VBoxGuestAdditions_${vb_version}.iso" "${additions_url}"
    fi
    # rm useless images
    remove_guest_additions_media
}

# Remove other (not needed) VBoxGuestAdditions from media directory
function remove_guest_additions_media {
    if [[ -z "${guest_additions_path}" ]]; then
        # nothing to do
        return
    fi
    guest_additions_path=$(prepare_path "${guest_additions_path}" 0)
    # true is use to not fail whole cmd, and return empty string 
    local file_list=$(ls "${guest_additions_path}" | grep "GuestAdditions" | grep -v "${vb_version}" || true)
    # continue only if we have some files to remove
    if [[ -z "${file_list}" ]]; then
        return
    fi
    printf "List of VBoxGuestAdditions files to remove:\n"
    for file in ${file_list}; do
        printf "${file}\n"
    done
    # to remove files ask about confirmation
    read -r -p "Do you want remove above VBoxGuestAdditions files? [y/N]" ans
    if [[ $ans =~ ^[Yy]$ ]]; then
        for file in ${file_list}; do
            printf "${file}\n"
            rm -f "${guest_additions_path}/${file}"
        done
    fi
}

# Prepare installation/boot media
function download_boot_media {
    local boot_file_path=$(dirname "${boot_file}")
    local boot_file_name=$(basename "${boot_file}")
    local boot_file_path=$(prepare_path "${boot_file_path}" 1)
    boot_file="${boot_file_path}/${boot_file_name}"
     
    # check whether boot file exist
    if [[ -f "${boot_file}" ]]; then
        # file exist, nothing to do
        return
    fi

    # boot_file_src is empty (not defined)
    if [[ -z "${boot_file_src}" ]]; then 
        red "${boot_file} not exist and boot_file_src is empty\n"
        return 1
    fi

    # the temporary name for boot_file is last part from boot_file_src
    local tmp_name=$(basename "${boot_file_src}")
    boot_file_src_path=$(prepare_path "${boot_file_src_path}" 1)
    local boot_file_src_file="${boot_file_src_path}/${tmp_name}"
    # check whether boot_file_src exist
    if [[ ! -f "${boot_file_src_file}" ]]; then
        curl -Lk "${boot_file_src}" -o "${boot_file_src_file}"
    fi

    # verify boot_file_src checksum
    local get_checksum=$(openssl "${boot_file_checksum_type}" "${boot_file_src_file}" | cut -d" " -f 2)
    if [[ "${boot_file_src_checksum}" != "${get_checksum}" ]]; then
        yellow "WARNING: CHECKSUM is different then expected !\n"
        read -r -p "Do you want continue? [y/N]" ans
        if [[ ! $ans =~ ^[Yy]$ ]]; then
            return 1
        fi
    else
        printf "INFO: CHECKSUM:${boot_file_src_checksum} is valid.\n"
    fi

    # process unpack
    if [[ ! -z "${boot_file_unpack_cmd}" ]]; then
        # check whether boot_file_unpack_name is empty if so then error
        if [[ -z "${boot_file_unpack_name}" ]]; then
            red "boot_file_unpack_name is empty, but boot_file_unpack_cmd is specify\n"
            return 1
        fi
        # prepare path - this is full path, must already exist in filesystem
        boot_file_unpack_name=$(prepare_path "${boot_file_unpack_name}" 0)
        # check whether boot_file_unpack_name exist - if not then run unpack cmd
        if [[ ! -f "${boot_file_unpack_name}" ]]; then
            # prepare and run unpack cmd
            boot_file_unpack_cmd=$(prepare_path "${boot_file_unpack_cmd}" 0)
            printf "${boot_file_unpack_cmd}\n"
            eval "${boot_file_unpack_cmd}"
        fi
        local boot_file_src_file="${boot_file_unpack_name}"
    fi

    # process convert from raw
    if [[ $boot_file_convert_from_raw -eq 1 ]]; then
        VBoxManage convertfromraw "${boot_file_src_file}" "${boot_file}" --format "${disk_format}"
        if [[ $keep_boot_src_file -eq 0 ]]; then
            rm -f "${boot_file_src_file}"
        fi
    else
        # check whether full path to boot_file_src_file is same as boot_file and boot_file was already created
        if [[ -f "${boot_file}" ]]; then
            return
        fi
        # check whether cp or mv; mv mean don't keep boot_file_src_file; keep only boot_file
        if [[ $keep_boot_src_file -eq 0 ]]; then
            mv -f "${boot_file_src_file}" "${boot_file}"
        else
            cp "${boot_file_src_file}" "${boot_file}"
        fi
    fi
}

# Prepare ssh keys
function get_priv_ssh_key {
    # check whether keys dir exist
    if [[ ! -d "${ssh_keys_path}" ]]; then
        printf "Creates vbkick ssh keys directory\n"
        mkdir "${ssh_keys_path}"
    fi
    # check whether private key exist
    if [[ ! -f "${ssh_keys_path}/${ssh_priv_key}" ]]; then
        curl -Lk "${ssh_priv_key_src}" -o "${ssh_keys_path}/${ssh_priv_key}"
    fi
    # change ssh key permissions - too open private key will be ignored
    chmod 600 "${ssh_keys_path}/${ssh_priv_key}"
}

function build_vm {
    # check whether VM already exist
    if VBoxManage list vms | grep -qw "${VM}"; then
        red "${VM} already exist\n"
        exit 1
    fi
    # load vm description/definition
    load_definition 
    # get ssh private key
    if [[ $ssh_keys_enabled -eq 1 ]]; then
        get_priv_ssh_key
    fi
    # check SSH port usage
    check_port_usage $ssh_host_port "SSH host"
    # start simple webserver (in background)
    start_web_server
    # download boot/iso files
    if ! download_boot_media; then 
        stop_web_server
        exit 1
    fi
    download_guest_additions_media
    # create VM box with given settings
    if ! create_box; then 
        stop_web_server
        exit 1
    fi
    # host ip to connect from guest
    local host_ip=10.0.2.2
    # start VM
    if [[ $gui_enabled -eq 1 ]]; then
        VBoxManage startvm --type gui "${VM}"  && sleep $boot_wait
    else
        VBoxManage startvm --type headless "${VM}" && sleep $boot_wait
    fi
    # boot VM machine
    for boot_cmd in "${boot_cmd_sequence[@]}"; do
        if [[ -z "${boot_cmd}" ]]; then 
            continue
        fi
        boot_cmd=${boot_cmd//%IP%/$host_ip}
        boot_cmd=${boot_cmd//%PORT%/$kickstart_port}
        boot_cmd=${boot_cmd//%NAME%/${VM}}
        printf "${boot_cmd}\n"
        # converts string to scancode via external python script
        local boot_cmd_code=$(printf "${boot_cmd}" | convert_2_scancode.py)
        # sends code to VM
        for code in $boot_cmd_code; do
            if [[ "${code}" == "wait" ]]; then
                sleep 1
            else
                VBoxManage controlvm "${VM}" keyboardputscancode $code
                sleep 0.02
            fi
        done
        sleep $boot_seq_wait
    done

    # wait until machine will be ready (ssh connection start working) or timeout was reached
    kickstart_monitoring

    # stop webserver
    stop_web_server

    exit 0
}

function create_box {
    # Register vm
    VBoxManage createvm --name "${VM}" --ostype "${os_type_id}" --register

    # Creates disks
    # Get default location for disks
    local location=$(VBoxManage list  systemproperties | grep "Default machine folder" | cut -d':' -f 2 | sed 's/^ *//g')

    # SATA controller - place for hdd and iso files
    # SATA controller allow add 30 disks, but vbkick reserve port 0 for boot media and port 1 for guest additions
    # check disk_size lenght
    if [[ ${#disk_size[@]} -gt 28 ]]; then
        red "Too many disks in disk_size (limited to 28 disks)\n"
        return 1; 
    fi
    if [[ "${vb_version}" > "4.3.0" ]] || [[ "${vb_version}" == "4.3.0" ]]; then
        VBoxManage storagectl "${VM}" --name "SATA Controller"\
        --add sata --hostiocache $hostiocache --portcount $((${#disk_size[@]}+2))
    else
        VBoxManage storagectl "${VM}" --name "SATA Controller"\
        --add sata --hostiocache $hostiocache --sataportcount $((${#disk_size[@]}+2))
    fi
    # SATA controller - add boot media
    VBoxManage storageattach "${VM}" --storagectl "SATA Controller"\
    --type "${boot_file_type}" --port 0 --device 0 --medium "${boot_file}"
    # SATA controller - create and add hdd disks
    local port_nr=2
    for disk in "${disk_size[@]}"; do
        if [[ -z "${disk}" ]]; then 
            continue
        fi
        VBoxManage createhd --filename "${location}/${VM}/${VM}-${port_nr}.${disk_format}"\
        --size $disk --format "${disk_format}" --variant Standard
        VBoxManage storageattach "${VM}" --storagectl "SATA Controller"\
        --port $port_nr --device 0 --type hdd --medium "${location}/${VM}/${VM}-${port_nr}.${disk_format}"
        local port_nr=$((port_nr+1))
    done
    # SATA controller - add VBoxGuestAdditions iso
    if [[ $guest_additions_attach -eq 1 ]]; then
        if [[ ! -z "${guest_additions_path}" ]]; then
            # custom VBoxGuestAdditions
            VBoxManage storageattach "${VM}" --storagectl "SATA Controller"\
            --type dvddrive --port 1 --device 0 --medium "${guest_additions_path}/VBoxGuestAdditions_${vb_version}.iso"
        else
            # default VBoxGuestAdditions
            VBoxManage storageattach "${VM}" --storagectl "SATA Controller"\
            --type dvddrive --port 1 --device 0 --medium emptydrive
            VBoxManage storageattach "${VM}" --storagectl "SATA Controller"\
            --type dvddrive --port 1 --device 0 --medium additions
        fi
    fi

    # Tuning VM
    # setting cpu's
    VBoxManage modifyvm "${VM}" --cpus $cpu_count
    # setting memory size
    VBoxManage modifyvm "${VM}" --memory $memory_size
    # setting video memory size
    VBoxManage modifyvm "${VM}" --vram $video_memory_size
    # setting bootorder
    VBoxManage modifyvm "${VM}" --boot1 disk --boot2 dvd --boot3 none --boot4 none
    # other settings
    for option in "${vm_options[@]}"; do
        if [[ -z "${option}" ]]; then
            continue
        fi
        local key="${option%%:*}"
        local value="${option##*:}"
        VBoxManage modifyvm "${VM}" --"${key}" "${value}"
    done
    # set extradata 
    for extradata in "${vm_extradata[@]}"; do
        if [[ -z "${extradata}" ]]; then
            continue
        fi
        local key="${extradata%%:*}"
        local value="${extradata##*:}"
        VBoxManage setextradata "${VM}" "${key}" "${value}"
    done

    # ssh port NAT mapping; ssh port is a special one
    if ! VBoxManage showvminfo "${VM}" | grep -q "${ssh_port_name}"; then
        VBoxManage controlvm "${VM}" natpf1 "${ssh_port_name},tcp,,${ssh_host_port},,${ssh_guest_port}"
    fi

    # extra ports NAT mapping
    add_extra_ports_mapping

    # add shared folders
    add_shared_folders
}

function add_extra_ports_mapping {
    for port in "${extra_ports[@]}"; do
        if [[ -z "${port}" ]]; then
            continue
        fi
        
        OIFS=$IFS
        IFS=':'
        local port_info=($port)
        if [[ ${#port_info[@]} -ne 3 ]]; then
            red "ERROR - one of the ports in extra_ports has invalid format.\n"
            exit 1
        fi
        local port_name="${port_info[0]}"
        local port_host="${port_info[1]}"
        local port_guest="${port_info[2]}"
        # add only if port doesn't exist
        if ! VBoxManage showvminfo "${VM}" | grep -q "${port_name}"; then
            VBoxManage controlvm "${VM}" natpf1 "${port_name},tcp,,${port_host},,${port_guest}"
        fi
        IFS=$OIFS
    done
}

function remove_extra_ports_mapping {
    for port in "${extra_ports[@]}"; do
        if [[ -z "${port}" ]]; then
            # note which extra ports were removed by moving extraports_removed_ptr
            extraports_removed_ptr=$((extraports_removed_ptr+1))
            continue
        fi
        local port_name=${port%%:*}
        if VBoxManage showvminfo "${VM}" | grep -qw "${port_name}"; then
            VBoxManage modifyvm "${VM}" --natpf1 delete "${port_name}"
            # note which extra ports were removed by moving extraports_removed_ptr
            extraports_removed_ptr=$((extraports_removed_ptr+1))
        fi
    done
}

function add_shared_folders {
    for folder in "${shared_folders[@]}"; do
        if [[ -z "${folder}" ]]; then
            continue
        fi

        OIFS=$IFS
        IFS=':'
        local folder_info=($folder)
        if [[ ${#folder_info[@]} -lt 2 ]]; then
            red "ERROR - one of the folders in shared_folders has no info about path.\n"
            exit 1
        fi
        local folder_name="${folder_info[0]}"
        local folder_path=$(prepare_path "${folder_info[1]}" 1)
        
        # check whether shared_folder already exist
        if VBoxManage showvminfo "${VM}" | grep -w 'machine mapping' | grep -qw "Name: '${folder_name}'"; then
            IFS=$OIFS
            continue
        fi

        if [[ ${#folder_info[@]} -eq 2 ]]; then
            printf "VBoxManage sharedfolder add  \"${VM}\" --name \"${folder_name}\" --hostpath \"${folder_path}\"\n"
            VBoxManage sharedfolder add  "${VM}" --name "${folder_name}" --hostpath "${folder_path}"
        elif [[ ${#folder_info[@]} -eq 3 ]]; then
            printf "VBoxManage sharedfolder add  \"${VM}\" --name \"${folder_name}\" --hostpath \"${folder_path}\" --${folder_info[2]}\n"
            VBoxManage sharedfolder add  "${VM}" --name "${folder_name}" --hostpath "${folder_path}" --"${folder_info[2]}"
        elif [[ ${#folder_info[@]} -eq 4 ]]; then
            printf "VBoxManage sharedfolder add  \"${VM}\" --name \"${folder_name}\" --hostpath \"${folder_path}\" --${folder_info[2]} --${folder_info[3]}\n"
            VBoxManage sharedfolder add  "${VM}" --name "${folder_name}" --hostpath "${folder_path}" --"${folder_info[2]}" --"${folder_info[3]}"
        else
            red "ERROR - too much options in one of the shared_folders.\n"
            exit 1
        fi
        IFS=$OIFS
    done
}

function remove_shared_folders {
    for folder in "${shared_folders[@]}"; do
        if [[ -z "${folder}" ]]; then
            # note which shared folders were removed by moving sharedfolders_removed_ptr
            sharedfolders_removed_ptr=$((sharedfolders_removed_ptr+1))
            continue
        fi
        local folder_name=${folder%%:*}
        if VBoxManage showvminfo "${VM}" | grep -w 'machine mapping' | grep -qw "Name: '${folder_name}'"; then
            VBoxManage sharedfolder remove  "${VM}" --name "${folder_name}"
            # note which shared folders were removed by moving sharedfolders_removed_ptr
            sharedfolders_removed_ptr=$((sharedfolders_removed_ptr+1))
        fi
    done
}

# Check whether machine was kickstarted before timeout
function kickstart_monitoring {
    local kickstart_counter=0
    local extra_ssh_options="-o ConnectionAttempts=1 -o ConnectTimeout=1"
    # ssh key authentication enabled
    if [[ $ssh_keys_enabled -eq 1 ]]; then
        # create path to ssh private key
        local key_path="${ssh_keys_path}/${ssh_priv_key}"
        printf "\nWaiting for ssh login with user ${ssh_user} to 127.0.0.1:${ssh_host_port} to work, kickstart_timeout=${kickstart_timeout} sec\n"
        # wait until ssh start working (communication chanel with VM) or kickstart_timeout was reached
        while ! ssh "${ssh_user}@127.0.0.1" -q -t -i ${key_path} -p $ssh_host_port $ssh_options $extra_ssh_options -C "echo"\
            && [[ $kickstart_counter -le $kickstart_timeout ]]; do
            kickstart_counter=$((kickstart_counter+1))
            printf "."
            sleep 1
        done
        printf "\n"
    else
        # if no ssh key authentication enabled then wait until timeout will be reached
        printf "Sleeping ${kickstart_timeout} seconds ...\n"
        sleep $kickstart_timeout
    fi
}

function destroy_vm {
    # check whether VM already exist
    if ! VBoxManage list vms | grep -qw "${VM}"; then
        red "${VM} doesn't exist\n"
        exit 1
    fi

    # destroy VM
    printf "Destroy ${VM}\n"
    read -r -p "Are you sure? [y/N]" ans
    if [[ ! $ans =~ ^[Yy]$ ]]; then
        exit 1
    fi

    # check whether VM is running
    if VBoxManage list runningvms | grep -qw "${VM}"; then
        printf "Poweroff ${VM}\n"
        VBoxManage controlvm "${VM}" poweroff
        sleep 1
    fi

    printf "Destroying...\n"
    VBoxManage unregistervm "${VM}" --delete
    exit 0
}

function export_vm {
    #
    # basic replacement for that vagrant command:
    # vagrant package --base "${VM}" --output "${VM}.box"
    # if more customisation required use: vagrant package (--help)
    #
    # tar command is required, check whether is installed
    depend_check "tar" "tar"
    # load vm description/definition
    load_definition
    # check whether VM_NAME.box exist in current dir
    if [[ -f "${VM}.box" ]]; then
        red "${VM}.box already exist in `pwd`\n"
        exit 1
    fi
    # check whether VM exist
    if ! VBoxManage list vms | grep -qw "${VM}"; then
        red "${VM} doesn't exist\n"
        exit 1
    fi
    # check whether VM is running and shutdown it 
    shutdown

    # clearing previously set port forwarding rules (only if exist)
    if VBoxManage showvminfo "${VM}" | grep -qw "${ssh_port_name}"; then
        VBoxManage modifyvm "${VM}" --natpf1 delete "${ssh_port_name}"
        ssh_natmapping_was_removed=1
    fi
    
    # rm extra ports (only if exist)
    remove_extra_ports_mapping
    
    # rm shared folder (only if exist)
    remove_shared_folders

    # create tmp_dir for export data
    tmp_dir=$(TMPDIR=. mktemp -d)
    # export VM to tmp_dir
    VBoxManage export "${VM}" --output "${tmp_dir}/box.ovf"
    # get VM MAC Address
    local mac_address=$(VBoxManage showvminfo --details --machinereadable "${VM}"\
    | grep macaddress1 | cut -d"=" -f 2)
    # add Vagrantfile
    printf "Vagrant.configure(\"2\") do |config|
    \t# This Vagrantfile is auto-generated by \`vagrant package\` to contain
    \t# the MAC address of the box. Custom configuration should be placed in
    \t# the actual \`Vagrantfile\` in this box.
    \tconfig.vm.base_mac = ${mac_address}
    end\n
    # Load include vagrant file if it exists after the auto-generated
    # so it can override any of the settings
    include_vagrantfile = File.expand_path(\"../include/_Vagrantfile\", __FILE__)
    load include_vagrantfile if File.exist?(include_vagrantfile)\n" > "${tmp_dir}/Vagrantfile"
    # add metadata.json
    printf "{\"provider\":\"virtualbox\"}\n" > "${tmp_dir}/metadata.json"
    # create VM_NAME.box (gzip) file
    cd $tmp_dir
    tar -cvzf "${VM}.box" *
    cd ..
    mv "${tmp_dir}/${VM}.box" .
    # remove tmp_dir
    rm -rf $tmp_dir
    # help recover some changes made on VM during exporting
    recover_vm_state
    printf "Done: `pwd`/${VM}.box\n"
    exit 0
}

function recover_vm_state {
    # add NAT mapping after exporting - only if exist prev.
    if [[ $ssh_natmapping_was_removed -eq 1 ]]; then
        VBoxManage controlvm "${VM}" natpf1 "${ssh_port_name},tcp,,${ssh_host_port},,${ssh_guest_port}"
        ssh_natmapping_was_removed=0
    fi
    # add extra ports after exporting - only if exist prev.
    if [[ $extraports_removed_ptr -gt 0 ]]; then
        # add only folders which were removed, skip others (useful when SIGINT)
        extra_ports=("${extra_ports[@]:0:$extraports_removed_ptr}")
        add_extra_ports_mapping
        extraports_removed_ptr=0
    fi
    # add shared folder after exporting - only if exist prev.
    if [[ $sharedfolders_removed_ptr -gt 0 ]]; then
        # add only folders which were removed, skip others (useful when SIGINT)
        shared_folders=("${shared_folders[@]:0:$sharedfolders_removed_ptr}")
        add_shared_folders
        sharedfolders_removed_ptr=0
    fi
}

function turn_on {
    # check whether VM is already running
    if VBoxManage list runningvms | grep -qw "${VM}"; then
        # nothing to do
        green "${VM} is already running...\n"
        exit 0
    fi
    
    # check whether VM already exist
    if ! VBoxManage list vms | grep -qw "${VM}"; then
        red "${VM} doese not exist. Use \"vbkick build\" to create the new VM.\n"
        exit 1
    fi

    if [[ $gui_enabled -eq 1 ]]; then
        VBoxManage startvm --type gui "${VM}"
    else
        VBoxManage startvm --type headless "${VM}"
    fi
}

function turn_off {
    # check whether VM is running
    if ! VBoxManage list runningvms | grep -qw "${VM}"; then
        green "${VM} is already turn off.\n"
        exit 0
    fi

    # load vm description/definition
    load_definition 

    #exec shutdown
    shutdown
}

function shutdown {
    # check whether VM is running and exec shutdown_cmd via SSH
    if VBoxManage list runningvms | grep -qw "${VM}"; then
        printf "Shutting down ${VM} "
        if [[ $ssh_keys_enabled -eq 1 ]]; then        
            # ssh key authentication enabled
            # if key not exist then get it
            get_priv_ssh_key
            # create path to ssh private key
            local key_path="${ssh_keys_path}/${ssh_priv_key}"
            ssh "${ssh_user}@127.0.0.1" -q -t -i ${key_path} -p $ssh_host_port $ssh_options -C "${shutdown_cmd}" || true
        else
            auto_passwd_ssh "${shutdown_cmd}"
        fi
        # wait until VM is down or shutdown_timeout was reached
        local shutdown_counter=0
        while VBoxManage list runningvms | grep -qw "${VM}" && [[ $shutdown_counter -le $shutdown_timeout ]]; do
            shutdown_counter=$((shutdown_counter+1))
            printf "."
            sleep 1
        done
    fi

    # check whether VM is still running, if so use acpipowerbutton
    if VBoxManage list runningvms | grep -qw "${VM}"; then
        VBoxManage controlvm "${VM}" acpipowerbutton
        printf "\n${VM} - acpipowerbutton was used. Waiting $shutdown_timeout seconds...\n"
        sleep $shutdown_timeout
    else
        printf "\n${VM} was shutdown cleanly.\n"
        sleep 3
        return
    fi

    # check whether VM is still running, if so poweroff it using hard way.
    if VBoxManage list runningvms | grep -qw "${VM}"; then
        VBoxManage controlvm "${VM}" poweroff
        printf "\n${VM} was powered off.\n"
        sleep 3
    else
        printf "\n${VM} was shutdown cleanly.\n"
        sleep 3
    fi
}

function update_guest_additions_media {
    # check whether VM exist
    if ! VBoxManage list vms | grep -qw "${VM}"; then
        red "${VM} doese not exist. Use \"vbkick build\" to create the new VM.\n"
        exit 1
    fi
    # get current guest version
    if VBoxManage guestproperty enumerate "${VM}" | grep -q "GuestAdd/Version"; then
        # guest already exist, get current version
        local guest_version=$(VBoxManage guestproperty get "${VM}" "/VirtualBox/GuestAdd/Version" | cut -f 2 -d " ")
    else
        # guest doesn't exist
        local guest_version=""
    fi
    
    # check whether we need update or install VBoxGuestAdditions
    if [[ "${vb_version}" == "${guest_version}" ]]; then
        green "VBoxGuestAdditions on ${VM} is up-to-date - update media iso is not needed.\n"
        return
    fi
    # TODO [LOW]: use Storage Controller Name (1) and type to find controller name
    # check whether "SATA Controller (1, 0)" exist - require to attach iso and creates /dev/sr1 or /dev/sr0
    if ! VBoxManage showvminfo "${VM}" | grep -qw "SATA Controller (1, 0)"; then
        red "\"SATA Controller (1, 0)\" for \"${VM}\" doesn't exist.\n"
        red "\"SATA Controller\" is sata controller name used by vbkick.\n"
        red "More: 'VBoxManage showvminfo \"${VM}\" | grep -w \"Controller\"'\n"
        red "\nTo create proper controller use:\n"
        red "'VBoxManage storagectl \"${VM}\" --name \"SATA Controller\" --add sata --hostiocache $hostiocache --portcount $((${#disk_size[@]}+2))'\n"
        red "'VBoxManage storageattach \"${VM}\" --storagectl \"SATA Controller\" --type dvddrive --port 1 --device 0 --medium emptydrive'\n"
        red "\nTo do this \"${VM}\" must be shutdown !!! \nRemember - VM Guest may have only one sata controller.\n"
        exit 1
    fi
    # Attach new VBoxGuestAdditions to install
    # vbkick creates VM with SATA Controller port 1 available for VBoxGuestAdditions iso.
    if [[ ! -z "${guest_additions_path}" ]]; then
        # custom VBoxGuestAdditions
        download_guest_additions_media
        VBoxManage storageattach "${VM}" --storagectl "SATA Controller"\
        --type dvddrive --port 1 --device 0 --medium "${guest_additions_path}/VBoxGuestAdditions_${vb_version}.iso" --forceunmount
    else
        # default VBoxGuestAdditions
        VBoxManage storageattach "${VM}" --storagectl "SATA Controller"\
        --type dvddrive --port 1 --device 0 --medium additions --forceunmount
    fi
    # Note: Guest OS (Linux) does not support automatic Guest Additions updating: 
    # VBoxManage guestcontrol <vmname>|<uuid> updateadditions
    # Manuall Guest Additions update/installation is required (via lazy_update cmd).
}

function validate_vm {
    #
    # test should be smart enough to check what I really want to test
    # e.g. If I don't need chef, don't test whether I have chef
    #
    # load vm description/definition
    load_definition
    # exec scripts on VM Guest via ssh
    ssh_exec ${#validate_transport[@]} "${validate_transport[@]}" "${validate_launch[@]}"
    exit 0
}

function lazy_postinstall {
    # load vm description/definition
    load_definition
    # exec scripts on VM Guest via ssh
    ssh_exec ${#postinstall_transport[@]} "${postinstall_transport[@]}" "${postinstall_launch[@]}"
    exit 0
}

function lazy_update {
    # load vm description/definition
    load_definition
    # Check whether VBoxGuestAdditions should be installed. If not then not update additions.
    if [[ $guest_additions_attach -eq 1 ]]; then
        update_guest_additions_media
    fi
    # Run other update scripts on VM Guest via ssh
    ssh_exec ${#update_transport[@]} "${update_transport[@]}" "${update_launch[@]}"
    exit 0
}

function ssh_exec {
    #
    # transport scripts to VM Guest via SCP and exec them via SSH
    #
    # get number of transport files/directories; transport array length
    local pos=$1
    shift
    # get transport array; everything to $pos
    local transport=("${@:1:$pos}")
    shift $pos
    # get launch array;
    local launch=("${@}")

    # check whether VM is running 
    if ! VBoxManage list runningvms | grep -qw "${VM}"; then
        red "${VM} is not running...\n"
        exit 1
    fi

    # checking port forwarding (if no proper rules, try add new one for NAT mapping)
    if ! VBoxManage showvminfo "${VM}" | grep "NIC 1" | grep "host port = ${ssh_host_port}"\
        | grep -q "guest port = ${ssh_guest_port}"; then
        printf "NAT mapping - enable ssh port forwarding\n"
        VBoxManage controlvm "${VM}" natpf1 "${ssh_port_name},tcp,,${ssh_host_port},,${ssh_guest_port}"
    fi

    # ssh key authentication enabled
    if [[ $ssh_keys_enabled -eq 1 ]]; then        
        # if key not exist then get it
        get_priv_ssh_key
        # create path to ssh private key
        local key_path="${ssh_keys_path}/${ssh_priv_key}"
    fi

    # check whether all pkt can by transported, before starting transporting
    for pkt in "${transport[@]}"; do
        if [[ -z "${pkt}" ]] || [[ -d "${pkt}" ]] || [[ -f "${pkt}" ]]; then
            continue
        else
            # pkt is neither file nor directory
            red "${pkt} is neither file nor directory\n"
            exit 1
        fi
    done

    # transport scripts to guest
    for pkt in "${transport[@]}"; do
        if [[ -z "${pkt}" ]]; then 
            continue
        fi
        printf "Scp: ${pkt}\n"
        # check whether pkt is file or dir
        if [[ -d "${pkt}" ]]; then
            # pkt is directory
            if [[ $ssh_keys_enabled -eq 1 ]]; then        
                scp -q -P $ssh_host_port -i "${key_path}" $ssh_options -r "${pkt}" "${ssh_user}@127.0.0.1:~${ssh_user}"
            else
                # 1 mean scp directory (recursive)
                auto_passwd_scp "${pkt}" 1
            fi
        elif [[ -f "${pkt}" ]]; then
            # pkt is file
            if [[ $ssh_keys_enabled -eq 1 ]]; then        
                scp -q -P $ssh_host_port -i "${key_path}" $ssh_options "${pkt}" "${ssh_user}@127.0.0.1:~${ssh_user}"
            else
                # 0 mean scp file
                auto_passwd_scp "${pkt}" 0
            fi
        fi
        sleep 1
    done

    # run commands via ssh
    for cmd in "${launch[@]}"; do
        if [[ -z "${cmd}" ]]; then 
            continue
        fi
        # %HOST% tag - check whether command should be executed on host (not guest)
        if [[ "${cmd}" =~ ^\ *%HOST% ]]; then
            # extract command
            cmd=${cmd//%HOST%/}
            # process defined/template variables
            cmd=$(prepare_path "${cmd}" 0)
            printf "Exec (on host): ${cmd}\n"
            eval "${cmd}"
            continue
        fi
        printf "Exec: ${cmd}\n"
        if [[ $ssh_keys_enabled -eq 1 ]]; then
            ssh -q "${ssh_user}@127.0.0.1" -t -i ${key_path} -p $ssh_host_port $ssh_options -C "${cmd}"
        else
            auto_passwd_ssh "${cmd}"
        fi
        sleep 1
    done
    
    # clean after scp by rm transported media/scripts
    if [[ $clean_transported -eq 1 ]]; then
        for pkt in "${transport[@]}"; do
            if [[ -z "${pkt}" ]]; then 
                continue
            fi
            printf "Clean transported: ${pkt}\n"
            local pkt_to_clean=$(basename "${pkt}")
            if [[ $ssh_keys_enabled -eq 1 ]]; then        
                ssh -q "${ssh_user}@127.0.0.1" -t -i ${key_path} -p $ssh_host_port $ssh_options -C "cd ~${ssh_user} && rm -rf ${pkt_to_clean}"
            else
                auto_passwd_ssh "cd ~${ssh_user} && rm -rf ${pkt_to_clean}"
            fi
            sleep 1
        done
    fi
}

function lazy_ssh {
    # check whether VM is running
    if ! VBoxManage list runningvms | grep -qw "${VM}"; then
        red "${VM} is not running...\n"
        exit 1
    fi
    # load vm description/definition
    load_definition
    if [[ $ssh_keys_enabled -eq 1 ]]; then
        # if key not exist then get it
        get_priv_ssh_key
        # create path to ssh private key
        local key_path="${ssh_keys_path}/${ssh_priv_key}"
        ssh -q "${ssh_user}@127.0.0.1" -t -i ${key_path} -p $ssh_host_port $ssh_options
    else
        auto_passwd_ssh ""
    fi
}

function auto_passwd_ssh {
    local _cmd="${1}"
    if command -v expect >/dev/null 2>&1; then
        if [[ -z "${_cmd}" ]]; then
            # No cmd to exec, interactive shell
            local _expect_cmd="ssh -q \"${ssh_user}@127.0.0.1\" -t -p $ssh_host_port $ssh_options"
        else
            local _expect_cmd="ssh -q \"${ssh_user}@127.0.0.1\" -t -p $ssh_host_port $ssh_options -C \"${_cmd}\""
        fi
        expect -c "log_user 0; spawn $_expect_cmd; expect password; send \"$ssh_password\r\"; interact; catch wait reason; exit [lindex \$reason 3]"
    else
        yellow "WARNING: 'expect' command not exist - install 'expect (tcl)' to automate ssh authentication without ssh_key.\n"
        yellow "To use ssh_key authentication setup ssh_keys_enabled=1 in your ${definition_fname}\n"
        # Process without expect
        if [[ -z "$_cmd" ]]; then
            # No cmd to exec, interactive shell
            ssh -q "${ssh_user}@127.0.0.1" -t -p $ssh_host_port $ssh_options
        else
            ssh -q "${ssh_user}@127.0.0.1" -t -p $ssh_host_port $ssh_options -C "${cmd}"
        fi
    fi
}

function auto_passwd_scp {
    #echo "Not implemented yet !"
    local _src="${1}"
    local _recursive="${2}"
    if command -v expect >/dev/null 2>&1; then
        if [[ $_recursive -eq 1 ]]; then
            local _expect_cmd="scp -q -P $ssh_host_port $ssh_options -r \"${_src}\" \"${ssh_user}@127.0.0.1:~${ssh_user}\""
        else
            local _expect_cmd="scp -q -P $ssh_host_port $ssh_options \"${_src}\" \"${ssh_user}@127.0.0.1:~${ssh_user}\""
        fi
        expect -c "log_user 0; spawn $_expect_cmd; expect password; send \"$ssh_password\r\"; expect eof; catch wait reason; exit [lindex \$reason 3]"
    else
        yellow "WARNING: 'expect' command not exist - install 'expect (tcl)' to automate ssh authentication without ssh_key.\n"
        yellow "To use ssh_key authentication setup ssh_keys_enabled=1 in your ${definition_fname}\n"
        # Process without expect
        if [[ $_recursive -eq 1 ]]; then
            scp -q -P $ssh_host_port $ssh_options -r "${_src}" "${ssh_user}@127.0.0.1:~${ssh_user}"
        else
            scp -q -P $ssh_host_port $ssh_options "${_src}" "${ssh_user}@127.0.0.1:~${ssh_user}"
        fi
    fi
}

# checks whether port is not used by other proc
function check_port_usage {
    local port_nr=$1
    local port_message="${2}"
    if (printf "" > /dev/tcp/127.0.0.1/$port_nr) 2>/dev/null; then
        red "$port_nr port (${port_message}) is already in use.\n"
        exit 1
    fi
}

function start_web_server {
    # Do not start webserver - remote server is used instead to serve kickstart files.
    if [[ $webserver_disabled -eq 1 ]]; then
        return
    fi
    # check whether port is not used by other proc
    check_port_usage $kickstart_port "kickstart"
    # start simple webserver serving files in background
    py_version=$(python -V 2>&1 | cut -d' ' -f 2 | cut -d'.' -f 1)
    if [[ $py_version -eq 2 ]]; then
        webserver_module="SimpleHTTPServer"
    elif [[ $py_version -eq 3 ]]; then
        webserver_module="http.server"
    else
        red "Unknown python version\n"
        exit 1
    fi
    python -m $webserver_module $kickstart_port &
    # get the pid already spawned process, to kill it later
    web_pid=$!
    # update webserver_status variable
    webserver_status=1
    sleep 2
    # check whether web server was really started
    if ! (printf "" > /dev/tcp/127.0.0.1/$kickstart_port) 2>/dev/null; then
        red "webserver was not started\n"
        if kill -s 0 $web_pid 2>/dev/null; then
            kill $web_pid
        fi
        exit 1
    fi
    printf "webserver has been started (pid $web_pid)\n"
}

function stop_web_server {
    # check whether webserver is running
    if [[ $webserver_status -eq 0 ]]; then
        return
    fi
    printf "Stopping webserver (pid $web_pid)\n"
    # with "set -e -E" if kill command fail then ERR trap is processing 
    # simply execution of function is not continued
    webserver_kill_cmd_status=1
    # check whether process exist and accept signals before sending SIGTERM
    if kill -s 0 $web_pid 2>/dev/null; then
        kill $web_pid
    fi
    webserver_kill_cmd_status=0
    # update webserver_status variable
    webserver_status=0
    # kill command is sucessfull when SIGTERM is sent to running process
    # not when child process was really killed
    if ! ps -ef | grep "python -m $webserver_module $kickstart_port" | grep -qv grep; then
        printf "INFO: webserver was stopped\n"
    else
        yellow "WARNING: problem with stopping webserver. Kill process manually\n"
        ps -ef | grep "python -m $webserver_module $kickstart_port" | grep -v grep
    fi
}

# (signals and error handler) - cleaning after ctr-c, etc.
function clean_up {
    printf "INFO: Signal/Error handler - cleanup before exiting...\n"
    if [[ $webserver_kill_cmd_status -eq 0 ]]; then
        # stop webserver (only if stop_web_server function didn't fail previuosly)
        stop_web_server
    else
        # previuosly executed stop_web_server function fail in killing $web_pid
        yellow "WARNING: problem with killing webserver (proc ${web_pid}). Kill process manually\n"
    fi
    # help recover some changes made on VM during exporting
    recover_vm_state
    # clean tmp_dir if exist
    if [[ -d $tmp_dir ]]; then
        rm -rf $tmp_dir
    fi
    exit 1
}

function depend_check {
    local dep_cmd="${1}"
    local dep_name="${2}"
    # check whether dep_name is installed - dep_cmd command exist
    if ! command -v $dep_cmd >/dev/null 2>&1; then
        red "$dep_cmd command not exist - install $dep_name to continue\n"
        exit 1
    fi
}

function dependencies_check {
    depend_check "VBoxManage" "Virtualbox"
    depend_check "curl" "curl"
    depend_check "ssh" "ssh-client (e.g. openssh-client)"
    depend_check "scp" "scp-client (e.g. openssh-client)"
    depend_check "python" "python"
    depend_check "bash" "bash"
    depend_check "openssl" "openssl"
}

function main {
    # 2 Args required, 3rd is optional - ACTION VM_NAME (DEFINITION_FILE_NAME)
    args_num=$#
    if [[ $args_num -lt 2 ]] || [[ $args_num -gt 3 ]]; then
        usage
        exit 1
    fi
    if [[ $args_num -eq 3 ]]; then
        definition_fname="${3}"
    fi

    # check whether we have everything to start with vbkick
    dependencies_check
    vb_version=$(get_vb_version)

    process_args "${1}" "${2}"
}

## MAIN ##
# signals and error handler
trap clean_up SIGHUP SIGINT SIGTERM ERR
main "$@"
